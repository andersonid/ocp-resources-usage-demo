<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Workshop - Escalonamento e Dimensionamento de Aplicações no OpenShift</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Red+Hat+Display:wght@400;500;600;700;800&family=Red+Hat+Text:wght@400;500;600;700&family=Red+Hat+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  :root {
    --r-background-color: #1a1a2e;
    --r-main-color: #e0e0e0;
    --r-heading-color: #ffffff;
    --r-link-color: #ee0000;
    --r-main-font: 'Red Hat Text', sans-serif;
    --r-heading-font: 'Red Hat Display', sans-serif;
    --r-code-font: 'Red Hat Mono', monospace;
    --red: #cc0000;
    --green: #2e7d32;
    --blue: #1565c0;
    --yellow: #f9a825;
    --orange: #e65100;
  }
  .reveal { font-size: 28px; font-family: 'Red Hat Text', sans-serif; }
  .global-logo { position: fixed; top: 12px; right: 16px; z-index: 100; pointer-events: none; }
  .global-logo img { width: 75px; opacity: 0.8; }
  .reveal h1 { font-size: 2.2em; color: var(--red); font-family: 'Red Hat Display', sans-serif; font-weight: 700; }
  .reveal h2 { font-size: 1.6em; color: #fff; border-bottom: 2px solid var(--red); padding-bottom: 10px; font-family: 'Red Hat Display', sans-serif; font-weight: 600; }
  .reveal h3 { font-size: 1.2em; color: #ccc; font-family: 'Red Hat Display', sans-serif; font-weight: 500; }
  .reveal .slide-number { font-size: 14px; }
  .reveal table { font-size: 0.75em; margin: 0 auto; }
  .reveal table th { background: var(--red); color: #fff; padding: 8px 14px; font-family: 'Red Hat Display', sans-serif; font-weight: 600; }
  .reveal table td { padding: 6px 14px; border-bottom: 1px solid #444; }
  .reveal pre { font-size: 0.65em; }
  .reveal code { font-size: 0.9em; font-family: 'Red Hat Mono', monospace; }
  .reveal .slides section { text-align: left; }
  .reveal .slides section.center { text-align: center; }
  .reveal img.slide-img { max-height: 55vh; border: none; box-shadow: none; background: transparent; }
  .badge-red { background: var(--red); color: #fff; padding: 4px 12px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
  .badge-green { background: var(--green); color: #fff; padding: 4px 12px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
  .badge-blue { background: var(--blue); color: #fff; padding: 4px 12px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
  .badge-yellow { background: var(--yellow); color: #000; padding: 4px 12px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
  .demo-indicator { color: #999; font-size: 0.8em; display: inline-block; margin-top: 10px; }
  .key-message { border-left: 4px solid var(--red); padding: 15px 20px; background: rgba(204,0,0,0.1); margin: 15px 0; font-style: italic; }
  .two-col { display: flex; gap: 30px; }
  .two-col > div { flex: 1; }
  .fragment.highlight-red.visible { color: var(--red); }
  ul { margin-left: 0; }
  li { margin-bottom: 8px; }
  .demo-btn {
    display: inline-block; padding: 8px 18px; margin: 5px 4px; border-radius: 6px;
    color: #fff !important; text-decoration: none !important; font-size: 0.8em; font-weight: bold;
    transition: all 0.2s;
  }
  .demo-btn:hover { opacity: 0.9; color: #ddd !important; }
  .demo-btn.red    { background: var(--red); }
  .demo-btn.green  { background: var(--green); }
  .demo-btn.blue   { background: var(--blue); }
  .demo-btn.orange { background: var(--orange); }
  .demo-btn.dark   { background: #444; }
  .demo-btn.disabled { background: #555; cursor: not-allowed; opacity: 0.5; }
  .demo-links { margin-top: 15px; }
</style>
</head>
<body>
<div class="global-logo"><img src="images/redhat-logo.svg" alt="Red Hat"></div>
<div class="reveal">
<div class="slides">

<!-- ============================================================ -->
<!-- TITLE -->
<!-- ============================================================ -->
<section class="center" data-background-color="#0e0e1a">
  <img src="images/redhat-logo.svg" alt="Red Hat" style="width:140px; margin-bottom:40px;">
  <h1 style="font-size:1.5em; margin-bottom:35px;">Escalonamento e Dimensionamento<br>de Aplicações no OpenShift</h1>
  <p style="color:#999;">Workshop Energisa</p>
  <p style="color:#666; font-size:0.7em; margin-top:32px;">Pressione <kbd style="background:#333;padding:2px 8px;border-radius:3px">S</kbd> para ver as notas do apresentador<br>
  Use as <kbd style="background:#333;padding:2px 8px;border-radius:3px">setas</kbd> para navegar</p>
  <div class="demo-links" style="margin-top:28px;" id="title-links">
    <a class="demo-btn blue" style="font-size:0.55em; padding:4px 10px;" href="https://console-openshift-console.__CLUSTER_DOMAIN__/dashboards" target="_blank">Console OpenShift</a>
    <a class="demo-btn blue" style="font-size:0.55em; padding:4px 10px;" href="https://console-openshift-console.__CLUSTER_DOMAIN__/terminal" target="_blank">Web Terminal</a>
    <a class="demo-btn blue" style="font-size:0.55em; padding:4px 10px;" href="https://openshift-gitops-server-openshift-gitops.__CLUSTER_DOMAIN__" target="_blank">Argo CD</a>
    <a class="demo-btn blue" style="font-size:0.55em; padding:4px 10px;" href="https://console-openshift-console.__CLUSTER_DOMAIN__/multicloud/infrastructure/clusters/managed" target="_blank">ACM Console</a>
  </div>
  <aside class="notes">
    Bom dia a todos. Esse workshop tem como objetivo mostrar na prática como dimensionar corretamente aplicações no OpenShift,
    evitando desperdício de recursos e garantindo que autoscaling funcione de verdade.
  </aside>
</section>

<!-- ============================================================ -->
<!-- PART 0 - EVOLUÇÃO DOS RECURSOS COMPUTACIONAIS -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>O Uso dos Recursos Computacionais</h2>
    <h3>A Evolução</h3>
    <aside class="notes">
      Antes de falar de Kubernetes e OpenShift, vamos relembrar como chegamos até aqui.
      A história dos recursos computacionais passa por várias fases, e cada uma trouxe avanços e novos problemas.
    </aside>
  </section>

  <section class="center">
    <h3 style="margin-bottom:25px; color:#999;">O jeito antigo -- Uma aplicação por servidor</h3>
    <div class="arch-stack" style="width:520px; margin:0 auto; position:relative;">

      <!-- Userspace (App + Libs) -->
      <div class="fragment fade-up" data-fragment-index="3" style="position:relative; z-index:3;">
        <div style="background:linear-gradient(135deg,#1565c0,#1e88e5); border-radius:10px 10px 0 0; padding:0; margin-bottom:2px; border:2px solid #42a5f5; overflow:hidden;">
          <div style="padding:10px 15px 6px; text-align:center; font-size:0.65em; color:#90caf9; text-transform:uppercase; letter-spacing:2px; border-bottom:1px solid rgba(255,255,255,0.15);">Userspace</div>
          <div style="display:flex; align-items:center; justify-content:center; padding:20px 15px 18px; gap:15px;">
            <div style="text-align:center;">
              <div style="font-size:2.2em;">&#9881;</div>
              <div style="font-size:0.85em; font-weight:bold; color:#fff; margin-top:4px;">Aplicação A</div>
            </div>
            <div style="color:rgba(255,255,255,0.3); font-size:1.4em;">+</div>
            <div style="text-align:center;">
              <div style="font-size:2.2em;">&#128218;</div>
              <div style="font-size:0.85em; font-weight:bold; color:#fff; margin-top:4px;">Libs / Deps</div>
            </div>
          </div>
        </div>
        <div class="fragment fade-in" data-fragment-index="4" style="position:absolute; right:-220px; top:50%; transform:translateY(-50%); width:200px; text-align:left;">
          <div style="font-size:0.7em; color:#f44336; border-left:3px solid #f44336; padding-left:10px;">
            &#9888; Se a app usar<br>pouca CPU/RAM,<br><strong>o resto é desperdiçado</strong>
          </div>
        </div>
      </div>

      <!-- Host Operating System -->
      <div class="fragment fade-up" data-fragment-index="2">
        <div style="background:linear-gradient(135deg,#2e7d32,#43a047); padding:14px 20px; margin-bottom:2px; border:2px solid #66bb6a; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.8em;">&#128421;</span>
          <div>
            <div style="font-size:0.95em; font-weight:bold; color:#fff;">Host Operating System</div>
            <div style="font-size:0.7em; color:#c8e6c9;">Linux, Windows Server...</div>
          </div>
        </div>
      </div>

      <!-- Infrastructure -->
      <div class="fragment fade-up" data-fragment-index="1">
        <div style="background:linear-gradient(135deg,#555,#777); border-radius:0 0 10px 10px; padding:14px 20px; border:2px solid #999; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.8em;">&#127981;</span>
          <div>
            <div style="font-size:0.95em; font-weight:bold; color:#fff;">Infrastructure</div>
            <div style="font-size:0.7em; color:#ccc;">CPU, RAM, Disco, Rede</div>
          </div>
        </div>
      </div>

    </div>
    <aside class="notes">
      Como era antes?
      Você tinha na sua infra um servidor com sua CPU e memória, o sistema operacional, e a sua aplicação rodava em cima desse SO e HW.
      Qual era o problema aqui? Se você tivesse uma aplicação que não estivesse usando todo o HW, você tinha um desperdício dos recursos computacionais.
      Então você precisava otimizar o uso desses recursos.
    </aside>
  </section>

  <section class="center">
    <h3 style="margin-bottom:25px; color:#999;">Múltiplas aplicações -- Melhor uso, zero isolamento</h3>
    <div class="arch-stack" style="width:520px; margin:0 auto; position:relative;">

      <!-- Userspace com múltiplas apps -->
      <div class="fragment fade-up" data-fragment-index="3" style="position:relative; z-index:3;">
        <div style="background:linear-gradient(135deg,#1565c0,#1e88e5); border-radius:10px 10px 0 0; padding:0; margin-bottom:2px; border:2px solid #42a5f5; overflow:hidden;">
          <div style="padding:10px 15px 6px; text-align:center; font-size:0.65em; color:#90caf9; text-transform:uppercase; letter-spacing:2px; border-bottom:1px solid rgba(255,255,255,0.15);">Userspace compartilhado</div>
          <div style="display:flex; align-items:stretch; justify-content:center; padding:15px 10px; gap:0;">
            <div style="text-align:center; flex:1; padding:8px;">
              <div style="font-size:1.8em;">&#9881;</div>
              <div style="font-size:0.75em; font-weight:bold; color:#fff;">App A</div>
              <div style="font-size:0.6em; color:#90caf9;">Libs v1</div>
            </div>
            <div style="width:1px; background:rgba(255,255,255,0.2);"></div>
            <div style="text-align:center; flex:1; padding:8px;">
              <div style="font-size:1.8em;">&#9881;</div>
              <div style="font-size:0.75em; font-weight:bold; color:#fff;">App B</div>
              <div style="font-size:0.6em; color:#90caf9;">Libs v2</div>
            </div>
            <div style="width:1px; background:rgba(255,255,255,0.2);"></div>
            <div style="text-align:center; flex:1; padding:8px;">
              <div style="font-size:1.8em;">&#9881;</div>
              <div style="font-size:0.75em; font-weight:bold; color:#fff;">App C</div>
              <div style="font-size:0.6em; color:#90caf9;">Libs v1</div>
            </div>
          </div>
        </div>
        <!-- Setas de conflito entre apps -->
        <div class="fragment fade-in" data-fragment-index="4" style="position:absolute; left:33%; top:55%; font-size:1.3em; color:#f44336; z-index:10;">&#8644;</div>
        <div class="fragment fade-in" data-fragment-index="4" style="position:absolute; left:63%; top:55%; font-size:1.3em; color:#f44336; z-index:10;">&#8644;</div>
      </div>

      <!-- Host Operating System -->
      <div class="fragment fade-up" data-fragment-index="2">
        <div style="background:linear-gradient(135deg,#2e7d32,#43a047); padding:14px 20px; margin-bottom:2px; border:2px solid #66bb6a; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.8em;">&#128421;</span>
          <div>
            <div style="font-size:0.95em; font-weight:bold; color:#fff;">Host Operating System</div>
            <div style="font-size:0.7em; color:#c8e6c9;">Bibliotecas compartilhadas</div>
          </div>
        </div>
      </div>

      <!-- Infrastructure -->
      <div class="fragment fade-up" data-fragment-index="1">
        <div style="background:linear-gradient(135deg,#555,#777); border-radius:0 0 10px 10px; padding:14px 20px; border:2px solid #999; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.8em;">&#127981;</span>
          <div>
            <div style="font-size:0.95em; font-weight:bold; color:#fff;">Infrastructure</div>
            <div style="font-size:0.7em; color:#ccc;">CPU, RAM, Disco, Rede</div>
          </div>
        </div>
      </div>

      <!-- Anotação lateral -->
      <div class="fragment fade-in" data-fragment-index="4" style="position:absolute; right:-230px; top:10px; width:210px; text-align:left;">
        <div style="font-size:0.7em; color:#f44336; border-left:3px solid #f44336; padding-left:10px;">
          &#9888; Sem isolamento!<br>
          App A pode consumir<br>recursos da App B.<br>
          <strong>Conflito de libs</strong> e<br><strong>perda de performance</strong>.
        </div>
      </div>
      <div class="fragment fade-in" data-fragment-index="5" style="position:absolute; left:-230px; top:10px; width:210px; text-align:right;">
        <div style="font-size:0.7em; color:#4caf50; border-right:3px solid #4caf50; padding-right:10px;">
          &#10003; Melhor aproveitamento<br>do hardware.<br>
          Menos servidores ociosos.
        </div>
      </div>

    </div>
    <aside class="notes">
      Como começou a otimizar? Colocar mais de uma aplicação no mesmo servidor.
      Qual o problema disso? Uma aplicação tinha acesso às mesmas coisas que as outras.
      Além disso, a Aplicação A pode consumir recursos da Aplicação B e gerar perda de performance de ambas.
      Você tinha melhor aproveitamento do HW, mas não tinha isolamento entre as aplicações.
    </aside>
  </section>

  <!-- SLIDE 3 - VIRTUALIZAÇÃO -->
  <section class="center">
    <h3 style="margin-bottom:25px; color:#999;">Virtualização -- Isolamento com overhead</h3>
    <div class="arch-stack" style="width:560px; margin:0 auto; position:relative;">

      <!-- VMs com apps isoladas -->
      <div class="fragment fade-up" data-fragment-index="4" style="position:relative; z-index:4;">
        <div style="display:flex; gap:4px; margin-bottom:2px;">
          <div style="flex:1; background:linear-gradient(135deg,#1565c0,#1e88e5); border-radius:10px 0 0 0; border:2px solid #42a5f5; padding:0; overflow:hidden;">
            <div style="padding:6px; text-align:center; font-size:0.55em; color:#90caf9; text-transform:uppercase; letter-spacing:1px; border-bottom:1px solid rgba(255,255,255,0.15);">VM 1</div>
            <div style="padding:8px 6px; text-align:center;">
              <div style="font-size:1.3em;">&#9881;</div>
              <div style="font-size:0.7em; font-weight:bold; color:#fff;">App A</div>
              <div style="font-size:0.55em; color:#90caf9;">Libs + Guest OS</div>
            </div>
          </div>
          <div style="flex:1; background:linear-gradient(135deg,#1565c0,#1e88e5); border:2px solid #42a5f5; padding:0; overflow:hidden;">
            <div style="padding:6px; text-align:center; font-size:0.55em; color:#90caf9; text-transform:uppercase; letter-spacing:1px; border-bottom:1px solid rgba(255,255,255,0.15);">VM 2</div>
            <div style="padding:8px 6px; text-align:center;">
              <div style="font-size:1.3em;">&#9881;</div>
              <div style="font-size:0.7em; font-weight:bold; color:#fff;">App B</div>
              <div style="font-size:0.55em; color:#90caf9;">Libs + Guest OS</div>
            </div>
          </div>
          <div style="flex:1; background:linear-gradient(135deg,#1565c0,#1e88e5); border-radius:0 10px 0 0; border:2px solid #42a5f5; padding:0; overflow:hidden;">
            <div style="padding:6px; text-align:center; font-size:0.55em; color:#90caf9; text-transform:uppercase; letter-spacing:1px; border-bottom:1px solid rgba(255,255,255,0.15);">VM 3</div>
            <div style="padding:8px 6px; text-align:center;">
              <div style="font-size:1.3em;">&#9881;</div>
              <div style="font-size:0.7em; font-weight:bold; color:#fff;">App C</div>
              <div style="font-size:0.55em; color:#90caf9;">Libs + Guest OS</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Hypervisor -->
      <div class="fragment fade-up" data-fragment-index="3">
        <div style="background:linear-gradient(135deg,#e65100,#f57c00); padding:12px 20px; margin-bottom:2px; border:2px solid #ff9800; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#9000;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Hypervisor</div>
            <div style="font-size:0.65em; color:#ffe0b2;">VMware, KVM, Hyper-V...</div>
          </div>
        </div>
      </div>

      <!-- Host OS -->
      <div class="fragment fade-up" data-fragment-index="2">
        <div style="background:linear-gradient(135deg,#2e7d32,#43a047); padding:12px 20px; margin-bottom:2px; border:2px solid #66bb6a; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#128421;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Host Operating System</div>
          </div>
        </div>
      </div>

      <!-- Infrastructure -->
      <div class="fragment fade-up" data-fragment-index="1">
        <div style="background:linear-gradient(135deg,#555,#777); border-radius:0 0 10px 10px; padding:12px 20px; border:2px solid #999; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#127981;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Infrastructure</div>
            <div style="font-size:0.65em; color:#ccc;">CPU, RAM, Disco, Rede</div>
          </div>
        </div>
      </div>

      <!-- Anotações -->
      <div class="fragment fade-in" data-fragment-index="5" style="position:absolute; right:-240px; top:0; width:220px; text-align:left;">
        <div style="font-size:0.7em; color:#4caf50; border-left:3px solid #4caf50; padding-left:10px;">
          &#10003; Isolamento completo<br>
          &#10003; Recursos limitados por VM<br>
          &#10003; Cada app tem seu SO
        </div>
      </div>
      <div class="fragment fade-in" data-fragment-index="6" style="position:absolute; left:-240px; top:0; width:220px; text-align:right;">
        <div style="font-size:0.7em; color:#f44336; border-right:3px solid #f44336; padding-right:10px;">
          &#9888; Overhead: SO em cima de SO<br>
          &#9888; Hypervisor consome recursos<br>
          &#9888; Boot lento, imagem pesada
        </div>
      </div>

    </div>
    <aside class="notes">
      Qual foi a primeira solução que apareceu? Virtualização.
      Você passa a ter ambientes segregados, onde nesta máquina virtual você tem um sistema operacional e suas bibliotecas específicas para aquela aplicação.
      E você consegue isolar todos os recursos computacionais para aquela aplicação, bem como limitar a quantidade de HW.
      Mas isso ainda gera problemas. Por quê? Você ainda tem um overhead de ter outro SO.
      O hypervisor nada mais é do que outro SO, e você acaba tendo essa sobreposição -- um SO em cima do outro. Não é o melhor dos cenários.
    </aside>
  </section>

  <!-- SLIDE 4 - CGROUPS -->
  <section class="center">
    <h3 style="margin-bottom:25px; color:#999;">cgroups -- Isolamento sem overhead de VM</h3>
    <div class="arch-stack" style="width:560px; margin:0 auto; position:relative;">

      <!-- Apps com cgroups -->
      <div class="fragment fade-up" data-fragment-index="3" style="position:relative; z-index:3;">
        <div style="display:flex; gap:4px; margin-bottom:2px;">
          <div style="flex:1; border-radius:10px 0 0 0; border:2px dashed #ff9800; padding:0; overflow:hidden; background:rgba(230,81,0,0.15);">
            <div style="padding:5px; text-align:center; font-size:0.5em; color:#ff9800; text-transform:uppercase; letter-spacing:1px;">cgroup 1</div>
            <div style="padding:6px; text-align:center;">
              <div style="font-size:1.3em;">&#9881;</div>
              <div style="font-size:0.7em; font-weight:bold; color:#fff;">App A</div>
            </div>
          </div>
          <div style="flex:1; border:2px dashed #ff9800; padding:0; overflow:hidden; background:rgba(230,81,0,0.15);">
            <div style="padding:5px; text-align:center; font-size:0.5em; color:#ff9800; text-transform:uppercase; letter-spacing:1px;">cgroup 2</div>
            <div style="padding:6px; text-align:center;">
              <div style="font-size:1.3em;">&#9881;</div>
              <div style="font-size:0.7em; font-weight:bold; color:#fff;">App B</div>
            </div>
          </div>
          <div style="flex:1; border-radius:0 10px 0 0; border:2px dashed #ff9800; padding:0; overflow:hidden; background:rgba(230,81,0,0.15);">
            <div style="padding:5px; text-align:center; font-size:0.5em; color:#ff9800; text-transform:uppercase; letter-spacing:1px;">cgroup 3</div>
            <div style="padding:6px; text-align:center;">
              <div style="font-size:1.3em;">&#9881;</div>
              <div style="font-size:0.7em; font-weight:bold; color:#fff;">App C</div>
            </div>
          </div>
        </div>
        <div style="background:linear-gradient(135deg,#1565c0,#1e88e5); padding:8px; text-align:center; border:2px solid #42a5f5; margin-bottom:2px; font-size:0.75em; color:#90caf9;">
          &#128218; Bibliotecas compartilhadas
        </div>
      </div>

      <!-- Host OS com cgroups -->
      <div class="fragment fade-up" data-fragment-index="2">
        <div style="background:linear-gradient(135deg,#2e7d32,#43a047); padding:12px 20px; margin-bottom:2px; border:2px solid #66bb6a; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#128421;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Host Operating System</div>
            <div style="font-size:0.65em; color:#c8e6c9;">Kernel Linux com suporte a cgroups</div>
          </div>
        </div>
      </div>

      <!-- Infrastructure -->
      <div class="fragment fade-up" data-fragment-index="1">
        <div style="background:linear-gradient(135deg,#555,#777); border-radius:0 0 10px 10px; padding:12px 20px; border:2px solid #999; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#127981;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Infrastructure</div>
            <div style="font-size:0.65em; color:#ccc;">Bare metal -- sem hypervisor</div>
          </div>
        </div>
      </div>

      <!-- Anotações -->
      <div class="fragment fade-in" data-fragment-index="4" style="position:absolute; right:-240px; top:0; width:220px; text-align:left;">
        <div style="font-size:0.7em; color:#4caf50; border-left:3px solid #4caf50; padding-left:10px;">
          &#10003; Limites de CPU e memória<br>
          &#10003; Sem overhead de VM<br>
          &#10003; Performance nativa<br>
          &#10003; Base do Kubernetes!
        </div>
      </div>
      <div class="fragment fade-in" data-fragment-index="5" style="position:absolute; left:-240px; top:0; width:220px; text-align:right;">
        <div style="font-size:0.7em; color:#f44336; border-right:3px solid #f44336; padding-right:10px;">
          &#9888; Bibliotecas compartilhadas<br>
          &#9888; Update do SO afeta tudo<br>
          &#9888; Sem isolamento de filesystem
        </div>
      </div>

    </div>
    <aside class="notes">
      A próxima evolução: cgroups. Isolamento e limites de recursos por aplicação, no mesmo sistema operacional.
      Você usa o SO diretamente no HW físico, isolando suas aplicações, mas ainda compartilhando as bibliotecas.
      O que é o cgroups? Um recurso do kernel Linux que limita, contabiliza e isola o uso de CPU, memória, IO de disco e rede de um conjunto de processos.
      O cgroups é um componente-chave dos containers -- e é por isso que conseguimos implementar requests e limits no Kubernetes.
      Basicamente, cgroups é o mecanismo que permite ao Kubernetes controlar quanto de CPU e memória cada container pode usar.
    </aside>
  </section>

  <!-- SLIDE 5 - CONTAINERS (cgroups + namespaces) -->
  <section class="center">
    <h3 style="margin-bottom:25px; color:#999;">Containers -- cgroups + namespaces</h3>
    <div class="arch-stack" style="width:560px; margin:0 auto; position:relative;">

      <!-- Containers isolados -->
      <div class="fragment fade-up" data-fragment-index="3" style="position:relative; z-index:3;">
        <div style="display:flex; gap:4px; margin-bottom:2px;">
          <div style="flex:1; border-radius:10px 0 0 0; border:2px solid #42a5f5; padding:0; overflow:hidden; background:linear-gradient(135deg,#0d47a1,#1565c0);">
            <div style="padding:5px; text-align:center; font-size:0.5em; color:#90caf9; text-transform:uppercase; letter-spacing:1px;">&#128230; Container 1</div>
            <div style="padding:6px 4px; text-align:center;">
              <div style="font-size:1.1em;">&#9881;</div>
              <div style="font-size:0.65em; font-weight:bold; color:#fff;">App A</div>
              <div style="font-size:0.5em; color:#90caf9;">Libs v1 | FS próprio</div>
            </div>
          </div>
          <div style="flex:1; border:2px solid #42a5f5; padding:0; overflow:hidden; background:linear-gradient(135deg,#0d47a1,#1565c0);">
            <div style="padding:5px; text-align:center; font-size:0.5em; color:#90caf9; text-transform:uppercase; letter-spacing:1px;">&#128230; Container 2</div>
            <div style="padding:6px 4px; text-align:center;">
              <div style="font-size:1.1em;">&#9881;</div>
              <div style="font-size:0.65em; font-weight:bold; color:#fff;">App B</div>
              <div style="font-size:0.5em; color:#90caf9;">Libs v2 | FS próprio</div>
            </div>
          </div>
          <div style="flex:1; border-radius:0 10px 0 0; border:2px solid #42a5f5; padding:0; overflow:hidden; background:linear-gradient(135deg,#0d47a1,#1565c0);">
            <div style="padding:5px; text-align:center; font-size:0.5em; color:#90caf9; text-transform:uppercase; letter-spacing:1px;">&#128230; Container 3</div>
            <div style="padding:6px 4px; text-align:center;">
              <div style="font-size:1.1em;">&#9881;</div>
              <div style="font-size:0.65em; font-weight:bold; color:#fff;">App C</div>
              <div style="font-size:0.5em; color:#90caf9;">Libs v1 | FS próprio</div>
            </div>
          </div>
        </div>
        <!-- Container Runtime -->
        <div style="background:linear-gradient(135deg,#4a148c,#6a1b9a); padding:8px; text-align:center; border:2px solid #9c27b0; margin-bottom:2px; font-size:0.75em; color:#ce93d8;">
          &#9654; Container Runtime <span style="font-size:0.8em; color:#e1bee7;">(CRI-O, containerd)</span>
        </div>
      </div>

      <!-- Host OS -->
      <div class="fragment fade-up" data-fragment-index="2">
        <div style="background:linear-gradient(135deg,#2e7d32,#43a047); padding:12px 20px; margin-bottom:2px; border:2px solid #66bb6a; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#128421;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Host Operating System</div>
            <div style="font-size:0.65em; color:#c8e6c9;">cgroups + namespaces (PID, NET, MNT, UTS, IPC)</div>
          </div>
        </div>
      </div>

      <!-- Infrastructure -->
      <div class="fragment fade-up" data-fragment-index="1">
        <div style="background:linear-gradient(135deg,#555,#777); border-radius:0 0 10px 10px; padding:12px 20px; border:2px solid #999; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.5em;">&#127981;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Infrastructure</div>
            <div style="font-size:0.65em; color:#ccc;">CPU, RAM, Disco, Rede</div>
          </div>
        </div>
      </div>

      <!-- Anotações -->
      <div class="fragment fade-in" data-fragment-index="4" style="position:absolute; right:-240px; top:0; width:220px; text-align:left;">
        <div style="font-size:0.7em; color:#4caf50; border-left:3px solid #4caf50; padding-left:10px;">
          &#10003; Isolamento completo<br>
          &#10003; Libs independentes<br>
          &#10003; Filesystem próprio<br>
          &#10003; Rede isolada (namespace)<br>
          &#10003; Sem overhead de VM<br>
          &#10003; Startup em segundos
        </div>
      </div>
      <div class="fragment fade-in" data-fragment-index="5" style="position:absolute; left:-240px; top:5px; width:220px; text-align:right;">
        <div style="font-size:0.7em; color:#ff9800; border-right:3px solid #ff9800; padding-right:10px;">
          &#9888; Compartilha o kernel<br>do host<br>
          &#9888; Bug de kernel afeta<br>o nó inteiro
        </div>
      </div>

    </div>
    <aside class="notes">
      Então começamos a usar cgroups mais namespaces do Linux. Namespaces são um recurso do kernel que particiona
      os recursos de forma que um conjunto de processos vê um conjunto de recursos, enquanto outro conjunto vê um conjunto diferente.
      Aqui, com os containers, já conseguimos manter as bibliotecas isoladas e customizadas por aplicação.
      Cada container tem seu próprio filesystem, sua rede, seus processos. Isolamento completo, sem o overhead de uma VM inteira.
    </aside>
  </section>

  <!-- SLIDE 6 - CONTAINERS + VIRTUALIZAÇÃO (O MELHOR DOS DOIS MUNDOS) -->
  <section class="center">
    <h3 style="margin-bottom:20px; color:#999;">O melhor dos dois mundos -- Kubernetes / OpenShift</h3>
    <div class="arch-stack" style="width:600px; margin:0 auto; position:relative;">

      <!-- Nós com containers -->
      <div class="fragment fade-up" data-fragment-index="4" style="position:relative; z-index:4;">
        <div style="display:flex; gap:6px; margin-bottom:2px;">
          <!-- Node 1 -->
          <div style="flex:1; border:2px solid #42a5f5; border-radius:8px 0 0 0; overflow:hidden; background:rgba(21,101,192,0.1);">
            <div style="background:linear-gradient(135deg,#1565c0,#1e88e5); padding:5px; text-align:center; font-size:0.55em; color:#fff; font-weight:bold;">&#9741; Node 1 (VM)</div>
            <div style="display:flex; gap:2px; padding:6px 4px;">
              <div style="flex:1; background:linear-gradient(135deg,#0d47a1,#1565c0); border-radius:4px; padding:4px; text-align:center;">
                <div style="font-size:0.9em;">&#128230;</div>
                <div style="font-size:0.5em; color:#fff;">App A</div>
              </div>
              <div style="flex:1; background:linear-gradient(135deg,#0d47a1,#1565c0); border-radius:4px; padding:4px; text-align:center;">
                <div style="font-size:0.9em;">&#128230;</div>
                <div style="font-size:0.5em; color:#fff;">App B</div>
              </div>
            </div>
          </div>
          <!-- Node 2 -->
          <div style="flex:1; border:2px solid #42a5f5; overflow:hidden; background:rgba(21,101,192,0.1);">
            <div style="background:linear-gradient(135deg,#1565c0,#1e88e5); padding:5px; text-align:center; font-size:0.55em; color:#fff; font-weight:bold;">&#9741; Node 2 (VM)</div>
            <div style="display:flex; gap:2px; padding:6px 4px;">
              <div style="flex:1; background:linear-gradient(135deg,#0d47a1,#1565c0); border-radius:4px; padding:4px; text-align:center;">
                <div style="font-size:0.9em;">&#128230;</div>
                <div style="font-size:0.5em; color:#fff;">App C</div>
              </div>
              <div style="flex:1; background:linear-gradient(135deg,#0d47a1,#1565c0); border-radius:4px; padding:4px; text-align:center;">
                <div style="font-size:0.9em;">&#128230;</div>
                <div style="font-size:0.5em; color:#fff;">App D</div>
              </div>
            </div>
          </div>
          <!-- Node 3 -->
          <div style="flex:1; border:2px solid #42a5f5; border-radius:0 8px 0 0; overflow:hidden; background:rgba(21,101,192,0.1);">
            <div style="background:linear-gradient(135deg,#1565c0,#1e88e5); padding:5px; text-align:center; font-size:0.55em; color:#fff; font-weight:bold;">&#9741; Node 3 (VM)</div>
            <div style="display:flex; gap:2px; padding:6px 4px;">
              <div style="flex:1; background:linear-gradient(135deg,#0d47a1,#1565c0); border-radius:4px; padding:4px; text-align:center;">
                <div style="font-size:0.9em;">&#128230;</div>
                <div style="font-size:0.5em; color:#fff;">App E</div>
              </div>
              <div style="flex:1; background:linear-gradient(135deg,#0d47a1,#1565c0); border-radius:4px; padding:4px; text-align:center;">
                <div style="font-size:0.9em;">&#128230;</div>
                <div style="font-size:0.5em; color:#fff;">App F</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Orquestrador -->
      <div class="fragment fade-up" data-fragment-index="3">
        <div style="background:linear-gradient(135deg,#b71c1c,#cc0000); padding:10px 20px; margin-bottom:2px; border:2px solid #ef5350; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.4em;">&#9096;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Kubernetes / OpenShift</div>
            <div style="font-size:0.6em; color:#ffcdd2;">Scheduler, kubelet, cgroups, namespaces</div>
          </div>
        </div>
      </div>

      <!-- Hypervisor -->
      <div class="fragment fade-up" data-fragment-index="2">
        <div style="background:linear-gradient(135deg,#e65100,#f57c00); padding:10px 20px; margin-bottom:2px; border:2px solid #ff9800; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.4em;">&#9000;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Hypervisor / Cloud Provider</div>
            <div style="font-size:0.6em; color:#ffe0b2;">AWS, Azure, vSphere, Bare Metal...</div>
          </div>
        </div>
      </div>

      <!-- Infrastructure -->
      <div class="fragment fade-up" data-fragment-index="1">
        <div style="background:linear-gradient(135deg,#555,#777); border-radius:0 0 10px 10px; padding:10px 20px; border:2px solid #999; display:flex; align-items:center; gap:12px; justify-content:center;">
          <span style="font-size:1.4em;">&#127981;</span>
          <div>
            <div style="font-size:0.9em; font-weight:bold; color:#fff;">Infrastructure</div>
            <div style="font-size:0.6em; color:#ccc;">Data Center / Nuvem</div>
          </div>
        </div>
      </div>

      <!-- Anotação -->
      <div class="fragment fade-in" data-fragment-index="5" style="position:absolute; right:-250px; top:0; width:230px; text-align:left;">
        <div style="font-size:0.7em; color:#4caf50; border-left:3px solid #4caf50; padding-left:10px;">
          &#10003; Isolamento de VM<br>
          &#10003; Eficiência de container<br>
          &#10003; Orquestração automática<br>
          &#10003; Scaling, self-healing<br>
          &#10003; Requests e Limits!
        </div>
      </div>
      <div class="fragment fade-in" data-fragment-index="6" style="position:absolute; left:-250px; top:10px; width:230px; text-align:right;">
        <div style="font-size:0.7em; color:#ff9800; border-right:3px solid #ff9800; padding-right:10px;">
          E é exatamente sobre<br>
          <strong style="color:#fff;">como configurar<br>corretamente os recursos</strong><br>
          que vamos falar agora.
        </div>
      </div>

    </div>
    <aside class="notes">
      Hoje em dia, trabalhamos com o melhor dos dois mundos: containers rodando dentro de VMs.
      No slide anterior, ainda usamos a infra inteira do nó. Se ocorrer um incidente como um bug de kernel, pode onerar o nó todo.
      Desse jeito, você cria máquinas virtuais específicas e customizadas, e coloca suas aplicações ali.
      É onde entra o Kubernetes e o OpenShift -- orquestrando tudo isso: recursos computacionais, nós, containers.
      Mas o orquestrador não adivinha de quanto cada aplicação precisa. Alguém precisa dizer isso pra ele.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 1 - O PROBLEMA REAL -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Um Problema Comum</h2>
    <aside class="notes">
      Agora que entendemos a evolução dos recursos computacionais, vamos falar de um problema que vemos com frequência em clusters de produção.
      Não é culpa de ninguém -- é um padrão comum que se repete quando não há orientação clara sobre como configurar recursos no Kubernetes.
    </aside>
  </section>

  <section>
    <h2>Padrões que se repetem</h2>
    <div class="fragment">
      <p><span class="badge-red">Tipo 1</span> Requests de CPU inflados</p>
      <p style="color:#999;font-size:0.85em;">Deployments pedem 300m, 500m, até 1000m. Uso real: 1m a 10m. Reservando 50x a 100x mais.</p>
    </div>
    <div class="fragment">
      <p><span class="badge-red">Tipo 2</span> Requests = Limits (QoS Guaranteed)</p>
      <p style="color:#999;font-size:0.85em;">Impede o Kubernetes de reaproveitar recursos ociosos. Faz sentido para bancos de dados, não para microsserviços.</p>
    </div>
    <div class="fragment">
      <p><span class="badge-red">Tipo 3</span> Multiplicação do problema</p>
      <p style="color:#999;font-size:0.85em;">50 microsserviços x 300m de request cada = 15 vCPUs reservadas. Uso real: 250m.</p>
    </div>
    <aside class="notes">
      Analisando clusters reais, identificamos padrões que se repetem em praticamente todos os clientes.
      Não vou apontar nomes -- o objetivo não é auditar ninguém, é mostrar oportunidades de melhoria.
      O impacto disso é concreto: o scheduler acha que os nodes estão cheios e pede mais nodes.
      O HPA nunca dispara. O cluster precisa de mais capacidade, mais subscrições, mais custo -- para rodar a mesma carga.
    </aside>
  </section>

  <section>
    <h2>O impacto concreto</h2>
    <ul>
      <li>O scheduler acha que os nodes estão <strong>cheios</strong></li>
      <li>O HPA <strong>nunca dispara</strong> -- o denominador (request) é gigante</li>
      <li>O cluster pede mais nodes = <strong>mais custo</strong></li>
      <li>Pods ficam em <strong>Pending</strong> por "Insufficient cpu" com nodes ociosos</li>
    </ul>
    <div class="key-message fragment">
      Isso não é culpa de ninguém. É um padrão comum. A mentalidade de "coloca recursos altos pra não dar problema"
      faz sentido para quem desenvolve, mas tem um custo real na plataforma.
    </div>
    <aside class="notes">
      É exatamente isso que vamos resolver hoje. Vamos entender por que isso acontece, como identificar, e como corrigir.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 2 - FUNDAMENTOS TÉCNICOS -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Fundamentos Técnicos</h2>
    <aside class="notes">
      Agora que entendemos o problema -- desperdício, HPA travado, overcommit escondido --
      vamos entender por que isso acontece. Quais são os mecanismos do Kubernetes por trás de tudo isso.
    </aside>
  </section>

  <!-- REQUESTS (visual interativo) -->
  <section class="center">
    <h3 style="margin-bottom:20px; color:#999;">Requests -- A reserva para o Scheduler</h3>
    <div style="display:flex; align-items:center; justify-content:center; gap:40px; margin-top:10px;">
      <div class="fragment fade-right" data-fragment-index="1" style="text-align:center;">
        <div style="border:3px solid #ff9800; border-radius:12px; padding:15px 20px; background:rgba(255,152,0,0.08);">
          <div style="border:2px dashed #ff9800; border-radius:8px; padding:12px 18px;">
            <div style="font-size:1.6em;">&#9881;</div>
            <div style="font-size:0.75em; color:#ff9800; font-weight:bold;">CONTAINER</div>
          </div>
          <div style="font-size:0.9em; font-weight:bold; color:#fff; margin-top:8px;">POD</div>
        </div>
      </div>
      <div class="fragment fade-in" data-fragment-index="2" style="font-size:1.5em; color:#999;">&#10132;</div>
      <div class="fragment fade-left" data-fragment-index="2" style="display:flex; gap:30px;">
        <div style="text-align:center;">
          <div style="width:60px; height:180px; border:3px solid #42a5f5; border-radius:6px; position:relative; overflow:hidden; background:rgba(66,165,245,0.05);">
            <div style="position:absolute; right:-18px; top:10%; font-size:0.45em; color:#666;">&#9472;</div>
            <div style="position:absolute; right:-18px; top:30%; font-size:0.45em; color:#666;">&#9472;</div>
            <div style="position:absolute; right:-18px; top:50%; font-size:0.45em; color:#666;">&#9472;</div>
            <div style="position:absolute; right:-18px; top:70%; font-size:0.45em; color:#666;">&#9472;</div>
            <div class="fragment fade-in" data-fragment-index="3" style="position:absolute; bottom:0; left:0; right:0; height:35%; background:linear-gradient(0deg,#1565c0,#42a5f5); opacity:0.8;"></div>
            <div class="fragment fade-in" data-fragment-index="3" style="position:absolute; bottom:33%; left:-5px; right:-5px; border-top:3px dashed #fff; z-index:2;"></div>
            <div class="fragment fade-in" data-fragment-index="3" style="position:absolute; bottom:36%; right:-70px; font-size:0.6em; color:#42a5f5; font-weight:bold; white-space:nowrap;">&#8592; request: 100m</div>
          </div>
          <div style="font-size:0.85em; font-weight:bold; color:#42a5f5; margin-top:8px;">CPU</div>
        </div>
        <div style="text-align:center;">
          <div style="width:60px; height:180px; border:3px solid #ab47bc; border-radius:6px; position:relative; overflow:hidden; background:rgba(171,71,188,0.05);">
            <div style="position:absolute; right:-18px; top:10%; font-size:0.45em; color:#666;">&#9472;</div>
            <div style="position:absolute; right:-18px; top:30%; font-size:0.45em; color:#666;">&#9472;</div>
            <div style="position:absolute; right:-18px; top:50%; font-size:0.45em; color:#666;">&#9472;</div>
            <div style="position:absolute; right:-18px; top:70%; font-size:0.45em; color:#666;">&#9472;</div>
            <div class="fragment fade-in" data-fragment-index="3" style="position:absolute; bottom:0; left:0; right:0; height:30%; background:linear-gradient(0deg,#7b1fa2,#ab47bc); opacity:0.8;"></div>
            <div class="fragment fade-in" data-fragment-index="3" style="position:absolute; bottom:28%; left:-5px; right:-5px; border-top:3px dashed #fff; z-index:2;"></div>
            <div class="fragment fade-in" data-fragment-index="3" style="position:absolute; bottom:31%; right:-80px; font-size:0.6em; color:#ab47bc; font-weight:bold; white-space:nowrap;">&#8592; request: 128Mi</div>
          </div>
          <div style="font-size:0.85em; font-weight:bold; color:#ab47bc; margin-top:8px;">MEMORY</div>
        </div>
      </div>
    </div>
    <div class="fragment fade-up" data-fragment-index="4" style="max-width:650px; margin:25px auto 0; text-align:center;">
      <div class="key-message" style="text-align:left;">
        O <strong>request</strong> diz ao Scheduler: "minha aplicação precisa de pelo menos isso para funcionar."<br>
        O Scheduler usa esse valor para decidir <strong>em qual nó</strong> colocar o pod.<br>
        <span style="color:#f44336;">Request alto demais</span> = nó "cheio" no papel, ocioso na prática.<br>
        <span style="color:#4caf50;">Request baixo demais</span> = muitos pods no mesmo nó, contenção de recursos.
      </div>
    </div>
    <aside class="notes">
      O request diz ao Scheduler o mínimo que a aplicação precisa. O Scheduler reserva isso no nó -- mesmo que a aplicação não use.
      Imaginem uma aplicação com request de 2 vCPUs mas que consome apenas 1 millicore em idle. O nó parece cheio no papel, mas na verdade está ocioso. É o cenário clássico de desperdício.
      Request alto demais: nó cheio no papel, ocioso na prática. Request baixo demais: muitos pods no mesmo nó, todos competindo pelos mesmos recursos.
    </aside>
  </section>

  <!-- LIMITS (visual interativo) -->
  <section class="center">
    <h3 style="margin-bottom:20px; color:#999;">Limits -- O teto máximo</h3>
    <div style="display:flex; align-items:center; justify-content:center; gap:40px; margin-top:10px;">
      <div style="text-align:center;">
        <div style="border:3px solid #ff9800; border-radius:12px; padding:15px 20px; background:rgba(255,152,0,0.08);">
          <div style="border:2px dashed #ff9800; border-radius:8px; padding:12px 18px;">
            <div style="font-size:1.6em;">&#9881;</div>
            <div style="font-size:0.75em; color:#ff9800; font-weight:bold;">CONTAINER</div>
          </div>
          <div style="font-size:0.9em; font-weight:bold; color:#fff; margin-top:8px;">POD</div>
        </div>
      </div>
      <div style="font-size:1.5em; color:#999;">&#10132;</div>
      <div style="display:flex; gap:30px;">
        <div style="text-align:center;">
          <div style="width:60px; height:180px; border:3px solid #42a5f5; border-radius:6px; position:relative; overflow:hidden; background:rgba(66,165,245,0.05);">
            <div style="position:absolute; bottom:0; left:0; right:0; height:35%; background:linear-gradient(0deg,#1565c0,#42a5f5); opacity:0.6;"></div>
            <div style="position:absolute; bottom:33%; left:-5px; right:-5px; border-top:2px dashed rgba(255,255,255,0.5); z-index:2;"></div>
            <div style="position:absolute; bottom:35%; right:-70px; font-size:0.5em; color:#90caf9; white-space:nowrap;">&#8592; request: 100m</div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:35%; left:0; right:0; height:30%; background:repeating-linear-gradient(45deg, rgba(66,165,245,0.3), rgba(66,165,245,0.3) 5px, rgba(66,165,245,0.1) 5px, rgba(66,165,245,0.1) 10px);"></div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:63%; left:-5px; right:-5px; border-top:3px solid #f44336; z-index:2;"></div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:66%; right:-65px; font-size:0.55em; color:#f44336; font-weight:bold; white-space:nowrap;">&#8592; limit: 200m</div>
          </div>
          <div style="font-size:0.85em; font-weight:bold; color:#42a5f5; margin-top:8px;">CPU</div>
          <div class="fragment fade-in" data-fragment-index="2" style="font-size:0.6em; color:#ff9800; margin-top:4px;">Acima do limit:<br><strong>Throttling</strong></div>
        </div>
        <div style="text-align:center;">
          <div style="width:60px; height:180px; border:3px solid #ab47bc; border-radius:6px; position:relative; overflow:hidden; background:rgba(171,71,188,0.05);">
            <div style="position:absolute; bottom:0; left:0; right:0; height:30%; background:linear-gradient(0deg,#7b1fa2,#ab47bc); opacity:0.6;"></div>
            <div style="position:absolute; bottom:28%; left:-5px; right:-5px; border-top:2px dashed rgba(255,255,255,0.5); z-index:2;"></div>
            <div style="position:absolute; bottom:30%; right:-80px; font-size:0.5em; color:#ce93d8; white-space:nowrap;">&#8592; request: 128Mi</div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:30%; left:0; right:0; height:30%; background:repeating-linear-gradient(45deg, rgba(171,71,188,0.3), rgba(171,71,188,0.3) 5px, rgba(171,71,188,0.1) 5px, rgba(171,71,188,0.1) 10px);"></div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:58%; left:-5px; right:-5px; border-top:3px solid #f44336; z-index:2;"></div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:61%; right:-75px; font-size:0.55em; color:#f44336; font-weight:bold; white-space:nowrap;">&#8592; limit: 256Mi</div>
          </div>
          <div style="font-size:0.85em; font-weight:bold; color:#ab47bc; margin-top:8px;">MEMORY</div>
          <div class="fragment fade-in" data-fragment-index="2" style="font-size:0.6em; color:#f44336; margin-top:4px;">Acima do limit:<br><strong>OOMKill</strong></div>
        </div>
      </div>
    </div>
    <div class="fragment fade-up" data-fragment-index="3" style="max-width:650px; margin:20px auto 0; text-align:center;">
      <div class="key-message" style="text-align:left;">
        O <strong>limit</strong> é o teto: até onde a aplicação pode chegar em picos de uso.<br>
        A zona entre request e limit é a <strong>zona de burst</strong> -- recursos disponíveis para picos.<br>
        <span style="color:#42a5f5;">CPU</span>: ultrapassou o limit? <strong>Throttling</strong> -- fica lenta, mas viva.<br>
        <span style="color:#ab47bc;">Memória</span>: ultrapassou o limit? <strong>OOMKill</strong> -- pod morto e reiniciado.
      </div>
    </div>
    <aside class="notes">
      O limit é o teto real, imposto pelo cgroup no kernel do Linux. Lembram do cgroups que vimos na evolução?
      É aqui que ele entra. Se o request é igual ao limit, não há zona de burst -- tudo trancado.
      Se o request é menor que o limit, existe uma zona de burst para absorver picos.
      CPU é compressível: ultrapassou, leva throttling. Memória é incompressível: ultrapassou, OOMKill.
      Essa diferença é fundamental para entender as decisões de configuração.
    </aside>
  </section>

  <!-- OVERCOMMIT (visual interativo) -->
  <section class="center">
    <h3 style="margin-bottom:8px; color:#999;">Overcommit -- Por que isso funciona</h3>
    <div style="display:flex; align-items:flex-end; justify-content:center; gap:40px;">

      <!-- Gráfico do nó (box 90x160 = 1000m, overflow 96px acima) -->
      <div style="position:relative; padding-top:130px;">
        <div style="display:flex; align-items:stretch; gap:8px;">
          <!-- Label capacidade à esquerda, vertical -->
          <div style="display:flex; align-items:center;">
            <div style="font-size:0.5em; color:#999; white-space:nowrap; writing-mode:vertical-lr; transform:rotate(180deg); letter-spacing:1px;">Capacidade do Nó: 1000m (1 vCPU)</div>
          </div>
          <!-- Box do nó -->
          <div style="width:90px; height:160px; border:2px solid #666; border-radius:4px; position:relative; background:rgba(255,255,255,0.03);">
            <!-- REQUESTS (sólidos) - escala: 160px = 1000m -->
            <!-- App A req: 300m = 48px -->
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:0; left:0; right:0; height:48px; background:linear-gradient(0deg,#1565c0,#1e88e5); opacity:0.85; border-radius:0 0 2px 2px;"></div>
            <!-- App B req: 250m = 40px -->
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:48px; left:0; right:0; height:40px; background:linear-gradient(0deg,#2e7d32,#43a047); opacity:0.85;"></div>
            <!-- App C req: 200m = 32px -->
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:88px; left:0; right:0; height:32px; background:linear-gradient(0deg,#e65100,#f57c00); opacity:0.85;"></div>
            <!-- Linha de requests (750m = 120px) -->
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:120px; left:-5px; right:-5px; border-top:2px dashed #fff; z-index:10;"></div>
            <div class="fragment fade-in" data-fragment-index="1" style="position:absolute; bottom:123px; left:-105px; font-size:0.45em; color:#fff; white-space:nowrap; font-weight:bold;">Requests: 750m &#8594;</div>

            <!-- LIMITS (hachurados, TRANSBORDAM) -->
            <!-- App A lim: 600m = 96px -->
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:0; left:3px; right:3px; height:96px; background:repeating-linear-gradient(45deg, rgba(66,165,245,0.25), rgba(66,165,245,0.25) 3px, transparent 3px, transparent 6px); border:1px dashed rgba(66,165,245,0.4);"></div>
            <!-- App B lim: 500m = 80px -->
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:96px; left:3px; right:3px; height:80px; background:repeating-linear-gradient(45deg, rgba(76,175,80,0.25), rgba(76,175,80,0.25) 3px, transparent 3px, transparent 6px); border:1px dashed rgba(76,175,80,0.4);"></div>
            <!-- App C lim: 500m = 80px (começa em 176px, transborda o box de 160px) -->
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:176px; left:3px; right:3px; height:80px; background:repeating-linear-gradient(45deg, rgba(255,152,0,0.25), rgba(255,152,0,0.25) 3px, transparent 3px, transparent 6px); border:1px dashed rgba(255,152,0,0.4);"></div>
            <!-- Linha de limits (1600m = 256px = 96px acima do box) -->
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:256px; left:-5px; right:-5px; border-top:2px solid #f44336; z-index:10;"></div>
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:259px; left:-110px; font-size:0.45em; color:#f44336; white-space:nowrap; font-weight:bold;">Limits: 1600m &#8594;</div>
            <!-- Zona de overcommit (96px acima do box) -->
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:160px; left:-2px; right:-2px; height:96px; border:2px dashed #f44336; border-top:none; background:rgba(244,67,54,0.06);"></div>
            <div class="fragment fade-in" data-fragment-index="2" style="position:absolute; bottom:196px; left:-110px; font-size:0.45em; color:#f44336; white-space:nowrap; text-align:right; line-height:1.3;">Overcommit &#8594;<br><span style="font-size:0.85em; color:#ff8a80;">600m acima</span></div>
          </div>
        </div>
      </div>

      <!-- Legenda (alinhada ao fundo do box) -->
      <div style="text-align:left; font-size:0.65em; padding-bottom:5px;">
        <div class="fragment fade-in" data-fragment-index="1">
          <div style="margin-bottom:8px;"><span style="display:inline-block; width:12px; height:12px; background:#1e88e5; border-radius:2px; vertical-align:middle; margin-right:6px;"></span> <strong>App A</strong> -- req: 300m, lim: 600m</div>
          <div style="margin-bottom:8px;"><span style="display:inline-block; width:12px; height:12px; background:#43a047; border-radius:2px; vertical-align:middle; margin-right:6px;"></span> <strong>App B</strong> -- req: 250m, lim: 500m</div>
          <div style="margin-bottom:8px;"><span style="display:inline-block; width:12px; height:12px; background:#f57c00; border-radius:2px; vertical-align:middle; margin-right:6px;"></span> <strong>App C</strong> -- req: 200m, lim: 500m</div>
          <div style="margin-top:6px; font-size:0.85em; color:#999;">
            <span style="display:inline-block; width:12px; height:12px; background:repeating-linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.3) 3px, transparent 3px, transparent 6px); border:1px dashed #999; border-radius:2px; vertical-align:middle; margin-right:6px;"></span> Hachurado = zona de burst
          </div>
        </div>
        <div class="fragment fade-in" data-fragment-index="3" style="margin-top:14px; border-left:3px solid #ff9800; padding-left:8px; color:#ff9800; line-height:1.3; font-size:0.9em;">
          Funciona porque nem todas<br>as apps usam o máximo<br>ao mesmo tempo.
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="4" style="max-width:620px; margin:10px auto 0; text-align:center;">
      <div class="key-message" style="text-align:left; font-size:0.85em; padding:10px 14px;">
        <strong>Overcommit de CPU</strong>: aceitável -- throttling é tolerável na maioria dos casos.<br>
        <strong>Overcommit de memória</strong>: perigoso -- OOMKill é destrutivo. Seja conservador com limits de memória.<br>
        A configuração ideal: <strong>requests realistas + limits com margem</strong> = cluster eficiente e seguro.
      </div>
    </div>
    <aside class="notes">
      Overcommit: neste exemplo o nó tem 1 vCPU (1000m). Os requests somam 750m -- cabem.
      Mas os limits somam 1600m -- 600m acima da capacidade real. Parece perigoso, mas funciona porque
      nem todas as apps usam o máximo ao mesmo tempo. Picos são distribuídos no tempo.
      Overcommit de CPU é aceitável -- throttling. Overcommit de memória é perigoso -- OOMKill.
      Agora vamos ver como o OpenShift aplica esses conceitos em dois momentos distintos.
    </aside>
  </section>

  <!-- SCHEDULER VS RUNTIME -->
  <section>
    <h2>Scheduler vs Runtime</h2>
    <div class="two-col">
      <div>
        <h3><span class="badge-blue">Scheduler</span></h3>
        <ul>
          <li>Decide <strong>onde</strong> o pod roda</li>
          <li>Olha os <strong>requests</strong></li>
          <li>Requests = <strong>reserva</strong></li>
          <li>Não sabe o uso real</li>
        </ul>
      </div>
      <div>
        <h3><span class="badge-yellow">Runtime (kubelet)</span></h3>
        <ul>
          <li>Controla <strong>o consumo</strong></li>
          <li>Olha os <strong>limits</strong></li>
          <li>Limits = <strong>teto</strong></li>
          <li>Usa cgroups para impor</li>
        </ul>
      </div>
    </div>
    <aside class="notes">
      Acabamos de ver requests, limits e overcommit. Mas em que momento cada um atua?
      São dois momentos distintos. Primeiro, o Scheduler -- ele olha os requests e decide em qual nó colocar o pod.
      Segundo, o Runtime -- kubelet e cgroups. Depois que o pod está rodando, quem controla o consumo real é o kubelet.
      Se o pod ultrapassar o limit de CPU, é throttled. Se ultrapassar memória, é OOMKilled.
    </aside>
  </section>

  <!-- CPU VS MEMÓRIA -->
  <section>
    <h2>CPU vs Memória</h2>
    <table>
      <thead><tr><th>Aspecto</th><th>CPU</th><th>Memória</th></tr></thead>
      <tbody>
        <tr><td>Tipo</td><td><span class="badge-green">Compressível</span></td><td><span class="badge-red">Incompressível</span></td></tr>
        <tr><td>No limit</td><td>Throttling (mais lento)</td><td>OOMKill (morto)</td></tr>
        <tr><td>Pod sobrevive?</td><td>Sim</td><td>Não</td></tr>
        <tr><td>Kernel toma de volta?</td><td>Sim, reduz ciclos</td><td>Não, mata o processo</td></tr>
        <tr><td>Impacto no usuário</td><td>Latência maior</td><td>Erro 500 / conexão perdida</td></tr>
      </tbody>
    </table>
    <aside class="notes">
      CPU é compressível -- o kernel limita ciclos sem matar. O pod fica lento mas continua vivo.
      Memória é incompressível -- uma vez alocada, o kernel não toma de volta sem matar.
      Essa diferença é crítica e vai impactar diretamente o comportamento do autoscaling, que veremos a seguir.
    </aside>
  </section>

  <!-- QOS -->
  <section>
    <h2>Requests, Limits e QoS</h2>
    <table>
      <thead><tr><th></th><th>Guaranteed</th><th>Burstable</th><th>BestEffort</th></tr></thead>
      <tbody>
        <tr><td>Configuração</td><td>req = limit</td><td>req &lt; limit</td><td>nenhum</td></tr>
        <tr><td>Burst?</td><td>Não</td><td>Sim</td><td>Ilimitado</td></tr>
        <tr><td>Eviction</td><td>Último</td><td>Médio</td><td>Primeiro</td></tr>
        <tr><td>Ideal para</td><td>DB, Kafka</td><td>Microsserviços</td><td>Jobs descartáveis</td></tr>
        <tr><td>HPA funciona?</td><td>Quase impossível</td><td>Sim</td><td>N/A</td></tr>
      </tbody>
    </table>
    <div class="key-message fragment">
      Guaranteed não significa "garante mais recursos". Significa que o pod tem um contrato fixo --
      nunca consome mais nem menos. Em troca, é o último a ser removido sob pressão.
    </div>
    <aside class="notes">
      O Kubernetes atribui automaticamente uma classe de QoS baseada na relação entre requests e limits.
      Guaranteed tranca recursos. Burstable permite burst. Para microsserviços, Burstable é quase sempre o caminho certo.
      Analogia: Guaranteed é reservar uma mesa de 10 lugares para jantar sozinho.
      Burstable é reservar 1 lugar e usar as cadeiras ao lado se estiverem vazias.
    </aside>
  </section>

  <!-- COMPARAÇÃO DIRETA -->
  <section>
    <h2>Comparação direta</h2>
    <table>
      <thead><tr><th>Aspecto</th><th style="color:#f44336">Guaranteed (2000m/2000m)</th><th style="color:#4caf50">Burstable (50m/200m)</th></tr></thead>
      <tbody>
        <tr><td>Reserva no scheduler</td><td>2000m (2 vCPUs)</td><td>50m</td></tr>
        <tr><td>Máximo que pode usar</td><td>2000m</td><td>200m</td></tr>
        <tr><td>Pods num node 8 vCPU</td><td>~4</td><td>~160</td></tr>
        <tr><td>CPU desperdiçada idle</td><td>~1995m trancados</td><td>~45m trancados</td></tr>
        <tr><td>HPA funciona?</td><td>Quase impossível</td><td>Sim</td></tr>
      </tbody>
    </table>
    <aside class="notes">
      Essa tabela resume tudo o que vimos até aqui. Guaranteed com 2000m/2000m versus Burstable com 50m/200m.
      O mesmo teto de segurança pode ser atingido com Burstable -- a diferença é que não tranca recursos no scheduler.
      Agora vamos ver isso na prática: temos dois apps de demonstração no cluster com exatamente essas configurações.
    </aside>
  </section>

  <!-- MANIFESTOS -->
  <section>
    <h2>Os manifestos dos nossos apps</h2>
    <div class="demo-indicator">DEMO -- Abrir terminal</div>
    <div class="demo-links">
      <a class="demo-btn orange" href="https://console-openshift-console.__CLUSTER_DOMAIN__/terminal" target="_blank">Abrir Web Terminal</a>
    </div>
    <div class="two-col" style="margin-top:20px;">
      <div>
        <h3 style="color:#f44336">app-ruim</h3>
        <pre><code class="yaml">resources:
  requests:
    cpu: "2"
    memory: 2Gi
  limits:
    cpu: "2"
    memory: 2Gi</code></pre>
        <p style="font-size:0.75em;color:#f44336">QoS: Guaranteed | HPA: morto</p>
      </div>
      <div>
        <h3 style="color:#4caf50">app-bom</h3>
        <pre><code class="yaml">resources:
  requests:
    cpu: 50m
    memory: 128Mi
  limits:
    cpu: 200m
    memory: 256Mi</code></pre>
        <p style="font-size:0.75em;color:#4caf50">QoS: Burstable | HPA: funcional</p>
      </div>
    </div>
    <aside class="notes">
      Vamos olhar no terminal. Dois namespaces: app-ruim e app-bom. Mesma aplicação, mesma imagem. A única diferença são os recursos.
      Executar: oc get deployment stress-app -n app-ruim -o yaml | grep -A 8 resources
      E depois: oc get deployment stress-app -n app-bom -o yaml | grep -A 8 resources
    </aside>
  </section>

  <!-- RESOURCE DASHBOARD -->
  <section>
    <h2>Vendo no Resource Dashboard</h2>
    <div class="demo-indicator">DEMO -- Abrir Resource Dashboard</div>
    <div class="demo-links">
      <a class="demo-btn green" href="https://resource-dashboard-demo-dashboard.__CLUSTER_DOMAIN__" target="_blank">Abrir Resource Dashboard</a>
    </div>
    <ul style="margin-top:20px;">
      <li><span style="color:#f44336">Lado esquerdo (vermelho)</span>: app-ruim -- uso real ~0%, requests ocupam tudo</li>
      <li><span style="color:#4caf50">Lado direito (verde)</span>: app-bom -- proporção saudável</li>
      <li>HPA do app-ruim: 0% de CPU. Target 70% = 1400m. <strong>Nunca vai disparar.</strong></li>
      <li>HPA do app-bom: 2% de CPU. Target 70% = 35m. <strong>Vai funcionar.</strong></li>
    </ul>
    <aside class="notes">
      Abrir o Resource Dashboard. Mostrar os dois lados.
      Apontar para o CPU atual dos dois: 0% no ruim, 2% no bom.
      Explicar: os dois consomem o mesmo CPU absoluto em idle (~1m). A diferença é o denominador.
      1m / 2000m = 0%. 1m / 50m = 2%. O HPA trabalha com essa porcentagem.
      Com isso, vocês já entendem o cenário todo. Agora vamos aprofundar no autoscaling -- como o Kubernetes ajusta dinamicamente a capacidade.
    </aside>
  </section>

  <!-- ============================================================ -->
  <!-- HPA - HORIZONTAL POD AUTOSCALER -->
  <!-- ============================================================ -->

  <!-- HPA-1: Deployment com replicas fixas -->
  <section class="center">
    <h3 style="margin-bottom:15px;">Horizontal Pod Autoscaler</h3>
    <p style="color:#999; font-size:0.75em; margin-bottom:20px;">Escalando horizontalmente -- mais pods</p>
    <div style="display:flex; align-items:center; justify-content:center; gap:20px; margin-top:10px;">

      <!-- Deployment box -->
      <div class="fragment fade-right" data-fragment-index="1" style="text-align:center;">
        <div style="border:2px solid #999; border-radius:8px; padding:12px 16px; background:rgba(255,255,255,0.05); min-width:100px;">
          <div style="font-size:0.65em; color:#aaa; font-family:monospace; text-align:left;">
            cpu: 100m<br>memory: 128Mi<br>replicas: <strong style="color:#fff;">3</strong>
          </div>
        </div>
        <div style="font-size:0.7em; color:#999; margin-top:6px;">Deployment</div>
      </div>

      <!-- Seta -->
      <div class="fragment fade-in" data-fragment-index="1" style="font-size:1.2em; color:#999;">&#10132;</div>

      <!-- Pods (todos iguais e ativos) -->
      <div class="fragment fade-left" data-fragment-index="1" style="display:flex; gap:12px;">
        <div style="text-align:center;">
          <div style="font-size:0.55em; color:#ff9800; margin-bottom:4px;">1</div>
          <div style="border:3px solid #ff9800; border-radius:10px; padding:10px 14px; background:rgba(255,152,0,0.08);">
            <div style="border:2px dashed #ff9800; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#ff9800;">CONTAINER</div>
            </div>
            <div style="font-size:0.65em; color:#fff; margin-top:4px;">POD</div>
          </div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:0.55em; color:#ff9800; margin-bottom:4px;">2</div>
          <div style="border:3px solid #ff9800; border-radius:10px; padding:10px 14px; background:rgba(255,152,0,0.08);">
            <div style="border:2px dashed #ff9800; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#ff9800;">CONTAINER</div>
            </div>
            <div style="font-size:0.65em; color:#fff; margin-top:4px;">POD</div>
          </div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:0.55em; color:#ff9800; margin-bottom:4px;">3</div>
          <div style="border:3px solid #ff9800; border-radius:10px; padding:10px 14px; background:rgba(255,152,0,0.08);">
            <div style="border:2px dashed #ff9800; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#ff9800;">CONTAINER</div>
            </div>
            <div style="font-size:0.65em; color:#fff; margin-top:4px;">POD</div>
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="2" style="max-width:600px; margin:20px auto 0;">
      <div class="key-message" style="text-align:left;">
        Um Deployment com <strong>replicas fixas</strong> mantém sempre o mesmo número de pods.<br>
        Mas a demanda varia ao longo do dia. Nem sempre você precisa de todas as replicas.
      </div>
    </div>
    <aside class="notes">
      O número de replicas de um Deployment é fixo. Se você configura 3, sempre terá 3 pods rodando.
      Mas a demanda real da aplicação varia. De madrugada, talvez 1 pod dê conta. No pico da tarde, talvez precise de 5.
      Manter replicas fixas significa desperdiçar recursos fora do pico ou faltar recursos durante o pico.
    </aside>
  </section>

  <!-- HPA-2: Replicas ociosas -->
  <section class="center">
    <h3 style="margin-bottom:15px;">Replicas fixas = desperdício</h3>
    <div style="display:flex; align-items:center; justify-content:center; gap:20px; margin-top:20px;">

      <div style="text-align:center;">
        <div style="border:2px solid #999; border-radius:8px; padding:12px 16px; background:rgba(255,255,255,0.05); min-width:100px;">
          <div style="font-size:0.65em; color:#aaa; font-family:monospace; text-align:left;">
            cpu: 100m<br>memory: 128Mi<br>replicas: <strong style="color:#fff;">3</strong>
          </div>
        </div>
        <div style="font-size:0.7em; color:#999; margin-top:6px;">Deployment</div>
      </div>

      <div style="font-size:1.2em; color:#999;">&#10132;</div>

      <div style="display:flex; gap:12px;">
        <!-- Pod 1 ativo -->
        <div style="text-align:center;">
          <div style="font-size:0.55em; color:#4caf50; margin-bottom:4px;">1</div>
          <div style="border:3px solid #4caf50; border-radius:10px; padding:10px 14px; background:rgba(76,175,80,0.08);">
            <div style="border:2px dashed #4caf50; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#4caf50;">ATIVO</div>
            </div>
            <div style="font-size:0.65em; color:#fff; margin-top:4px;">POD</div>
          </div>
        </div>
        <!-- Pod 2 ocioso -->
        <div class="fragment fade-in" data-fragment-index="1" style="text-align:center; opacity:0.4;">
          <div style="font-size:0.55em; color:#999; margin-bottom:4px;">2</div>
          <div style="border:3px dashed #666; border-radius:10px; padding:10px 14px; background:rgba(255,255,255,0.02);">
            <div style="border:2px dashed #666; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em; opacity:0.5;">&#9881;</div>
              <div style="font-size:0.5em; color:#666;">OCIOSO</div>
            </div>
            <div style="font-size:0.65em; color:#666; margin-top:4px;">POD</div>
          </div>
        </div>
        <!-- Pod 3 ocioso -->
        <div class="fragment fade-in" data-fragment-index="1" style="text-align:center; opacity:0.4;">
          <div style="font-size:0.55em; color:#999; margin-bottom:4px;">3</div>
          <div style="border:3px dashed #666; border-radius:10px; padding:10px 14px; background:rgba(255,255,255,0.02);">
            <div style="border:2px dashed #666; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em; opacity:0.5;">&#9881;</div>
              <div style="font-size:0.5em; color:#666;">OCIOSO</div>
            </div>
            <div style="font-size:0.65em; color:#666; margin-top:4px;">POD</div>
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="2" style="max-width:600px; margin:20px auto 0;">
      <div class="key-message" style="text-align:left;">
        Fora do horário de pico, apenas 1 pod está processando. Os outros 2 <strong>consomem recursos sem necessidade</strong>.<br>
        E se a demanda superar 3 pods? Não há como escalar além do fixo.
      </div>
    </div>
    <aside class="notes">
      Esse é o cenário típico: 3 replicas fixas, mas fora do pico apenas 1 pod está de fato processando requisições.
      Os outros 2 estão lá, consumindo CPU e memória do nó, reservando requests no scheduler, sem fazer nada útil.
      E no cenário oposto, se a demanda explodir, 3 pods pode não ser suficiente. Replicas fixas não se adaptam.
    </aside>
  </section>

  <!-- HPA-3: HPA em ação - scale up -->
  <section class="center">
    <h3 style="margin-bottom:10px;">HPA -- Scale Up automático</h3>
    <div style="display:flex; flex-direction:column; align-items:center; gap:15px; margin-top:15px;">

      <!-- Linha de cima: Deployment + Pods -->
      <div style="display:flex; align-items:center; justify-content:center; gap:20px;">
        <div style="text-align:center;">
          <div style="border:2px solid #999; border-radius:8px; padding:10px 14px; background:rgba(255,255,255,0.05);">
            <div style="font-size:0.6em; color:#aaa; font-family:monospace; text-align:left;">cpu: 100m<br>memory: 128Mi</div>
          </div>
          <div style="font-size:0.65em; color:#999; margin-top:4px;">Deployment</div>
        </div>

        <div style="font-size:1.2em; color:#999;">&#10132;</div>

        <!-- Pod 1 sob pressão -->
        <div style="text-align:center;">
          <div style="font-size:0.5em; color:#f44336; margin-bottom:3px;">1</div>
          <div style="border:3px solid #f44336; border-radius:10px; padding:8px 12px; background:rgba(244,67,54,0.1);">
            <div style="border:2px dashed #f44336; border-radius:6px; padding:6px 8px;">
              <div style="font-size:0.8em;">&#9881;</div>
              <div style="font-size:0.45em; color:#f44336;">85% CPU</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>

        <div style="font-size:0.9em; color:#999;">...</div>

        <!-- Novos pods aparecendo -->
        <div class="fragment fade-in" data-fragment-index="2" style="display:flex; gap:10px;">
          <div style="text-align:center;">
            <div style="font-size:0.5em; color:#4caf50; margin-bottom:3px;">2</div>
            <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
              <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
                <div style="font-size:0.45em; color:#4caf50;">NOVO</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
          <div style="text-align:center;">
            <div style="font-size:0.5em; color:#4caf50; margin-bottom:3px;">N</div>
            <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
              <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
                <div style="font-size:0.45em; color:#4caf50;">NOVO</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Linha de baixo: HPA + Monitoring -->
      <div style="display:flex; align-items:center; justify-content:center; gap:30px;">
        <!-- HPA -->
        <div class="fragment fade-up" data-fragment-index="1" style="text-align:center;">
          <div style="border:2px solid #42a5f5; border-radius:8px; padding:10px 16px; background:rgba(66,165,245,0.08);">
            <div style="font-size:0.6em; color:#42a5f5; font-weight:bold;">HPA</div>
            <div style="font-size:0.55em; color:#aaa; font-family:monospace; margin-top:4px;">target: <strong style="color:#ff9800;">70%</strong> CPU</div>
            <div style="font-size:0.55em; color:#aaa; font-family:monospace;">min: 1 | max: 5</div>
          </div>
        </div>

        <div class="fragment fade-in" data-fragment-index="1" style="font-size:1em; color:#999;">&#10229;</div>

        <!-- Monitoring -->
        <div class="fragment fade-up" data-fragment-index="1" style="text-align:center;">
          <div style="border:2px solid #ff9800; border-radius:8px; padding:10px 16px; background:rgba(255,152,0,0.08);">
            <div style="font-size:0.6em; color:#ff9800; font-weight:bold;">Metrics Server</div>
            <div style="font-size:0.55em; color:#f44336; font-family:monospace; margin-top:4px;">cpu: <strong>85%</strong> &#9650;</div>
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="3" style="max-width:650px; margin:15px auto 0;">
      <div class="key-message" style="text-align:left;">
        O HPA compara o uso real (85%) com o target (70%). Resultado: <strong>cria novas replicas</strong>.<br>
        O cálculo usa os <strong>requests</strong> como referência. Request de 100m + target 70% = escala quando chegar em 70m.
      </div>
    </div>
    <aside class="notes">
      O HPA monitora o uso real de CPU (via Metrics Server) e compara com o target que você definiu.
      O cálculo é baseado nos requests, não nos limits. Se o request é 100m e o target é 70%,
      quando o uso médio dos pods chegar em 70m, o HPA cria uma nova replica.
      Por isso o app-ruim com request de 2000m e target de 70% nunca escala -- 70% de 2000m é 1400m,
      e a app idle nunca chega perto disso.
    </aside>
  </section>

  <!-- HPA-4: Após scale - carga distribuída -->
  <section class="center">
    <h3 style="margin-bottom:10px;">HPA -- Carga distribuída</h3>
    <div style="display:flex; flex-direction:column; align-items:center; gap:15px; margin-top:15px;">

      <!-- Pods agora balanceados -->
      <div style="display:flex; align-items:center; justify-content:center; gap:20px;">
        <div style="text-align:center;">
          <div style="border:2px solid #999; border-radius:8px; padding:10px 14px; background:rgba(255,255,255,0.05);">
            <div style="font-size:0.6em; color:#aaa; font-family:monospace; text-align:left;">cpu: 100m<br>memory: 128Mi</div>
          </div>
          <div style="font-size:0.65em; color:#999; margin-top:4px;">Deployment</div>
        </div>

        <div style="font-size:1.2em; color:#999;">&#10132;</div>

        <div style="display:flex; gap:10px;">
          <div style="text-align:center;">
            <div style="font-size:0.5em; color:#4caf50; margin-bottom:3px;">1</div>
            <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
              <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
                <div style="font-size:0.45em; color:#4caf50;">35% CPU</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
          <div style="text-align:center;">
            <div style="font-size:0.5em; color:#4caf50; margin-bottom:3px;">2</div>
            <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
              <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
                <div style="font-size:0.45em; color:#4caf50;">35% CPU</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
          <div style="text-align:center; opacity:0.4;">
            <div style="font-size:0.5em; color:#999; margin-bottom:3px;">N</div>
            <div style="border:3px dashed #666; border-radius:10px; padding:8px 12px; background:rgba(255,255,255,0.02);">
              <div style="border:2px dashed #666; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em; opacity:0.5;">&#9881;</div>
                <div style="font-size:0.45em; color:#666;">STANDBY</div>
              </div>
              <div style="font-size:0.6em; color:#666; margin-top:3px;">POD</div>
            </div>
          </div>
        </div>
      </div>

      <!-- HPA + Monitoring -->
      <div style="display:flex; align-items:center; justify-content:center; gap:30px;">
        <div style="text-align:center;">
          <div style="border:2px solid #42a5f5; border-radius:8px; padding:10px 16px; background:rgba(66,165,245,0.08);">
            <div style="font-size:0.6em; color:#42a5f5; font-weight:bold;">HPA</div>
            <div style="font-size:0.55em; color:#aaa; font-family:monospace; margin-top:4px;">target: <strong style="color:#ff9800;">70%</strong> CPU</div>
          </div>
        </div>
        <div style="font-size:1em; color:#999;">&#10229;</div>
        <div style="text-align:center;">
          <div style="border:2px solid #4caf50; border-radius:8px; padding:10px 16px; background:rgba(76,175,80,0.08);">
            <div style="font-size:0.6em; color:#4caf50; font-weight:bold;">Metrics Server</div>
            <div style="font-size:0.55em; color:#4caf50; font-family:monospace; margin-top:4px;">cpu: <strong>35%</strong> &#9660;</div>
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="1" style="max-width:650px; margin:15px auto 0;">
      <div class="key-message" style="text-align:left;">
        Com 2 pods, a carga cai para ~35% cada. O HPA <strong>não escala mais</strong> porque está abaixo do target.<br>
        <span style="color:#ff9800;">Cuidado</span>: se o target for mal dimensionado, pode gerar <strong>flapping</strong> -- cria e destrói pods em loop.<br>
        <span style="color:#42a5f5;">HPA nativo funciona bem por CPU</span>. Para escalar por requisições/s, considere <strong>KEDA</strong> (Custom Metrics).
      </div>
    </div>
    <aside class="notes">
      Com 2 pods, o Service distribui a carga e cada pod cai para ~35%. O HPA vê que está abaixo do target e para de escalar.
      Ponto importante: se o target estiver mal configurado, pode gerar flapping -- escala, a carga cai, remove o pod, a carga sobe, escala de novo.
      Outro ponto: o HPA nativo do Kubernetes funciona bem por CPU. Para memória, o comportamento é imprevisível porque memória é incompressível.
      Para cenários mais avançados como escalar por requisições por segundo, existe o KEDA, que já está disponível no OpenShift como Custom Metrics Autoscaler.
      Vamos demonstrar o HPA do app-bom na prática mais adiante.
    </aside>
  </section>

  <!-- ============================================================ -->
  <!-- VPA - VERTICAL POD AUTOSCALER -->
  <!-- ============================================================ -->

  <!-- VPA-1: Deployment com recursos fixos -->
  <section class="center">
    <h3 style="margin-bottom:15px;">Vertical Pod Autoscaler</h3>
    <p style="color:#999; font-size:0.75em; margin-bottom:20px;">Escalando verticalmente -- pods maiores</p>
    <div style="display:flex; align-items:center; justify-content:center; gap:20px; margin-top:10px;">

      <div class="fragment fade-right" data-fragment-index="1" style="text-align:center;">
        <div style="border:2px solid #999; border-radius:8px; padding:12px 16px; background:rgba(255,255,255,0.05); min-width:110px;">
          <div style="font-size:0.65em; color:#aaa; font-family:monospace; text-align:left;">
            cpu: <strong style="color:#42a5f5;">100m</strong><br>memory: <strong style="color:#ab47bc;">512Mi</strong>
          </div>
        </div>
        <div style="font-size:0.7em; color:#999; margin-top:6px;">Deployment</div>
      </div>

      <div class="fragment fade-in" data-fragment-index="1" style="font-size:1.2em; color:#999;">&#10132;</div>

      <div class="fragment fade-left" data-fragment-index="1" style="display:flex; gap:12px;">
        <div style="text-align:center;">
          <div style="font-size:0.5em; color:#ff9800; margin-bottom:3px;">1</div>
          <div style="border:3px solid #ff9800; border-radius:10px; padding:10px 14px; background:rgba(255,152,0,0.08); transition:all 0.5s;">
            <div style="border:2px dashed #ff9800; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#ff9800;">CONTAINER</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:0.5em; color:#ff9800; margin-bottom:3px;">2</div>
          <div style="border:3px solid #ff9800; border-radius:10px; padding:10px 14px; background:rgba(255,152,0,0.08);">
            <div style="border:2px dashed #ff9800; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#ff9800;">CONTAINER</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:0.5em; color:#ff9800; margin-bottom:3px;">3</div>
          <div style="border:3px solid #ff9800; border-radius:10px; padding:10px 14px; background:rgba(255,152,0,0.08);">
            <div style="border:2px dashed #ff9800; border-radius:6px; padding:8px 10px;">
              <div style="font-size:0.9em;">&#9881;</div>
              <div style="font-size:0.5em; color:#ff9800;">CONTAINER</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="2" style="max-width:600px; margin:20px auto 0;">
      <div class="key-message" style="text-align:left;">
        Diferente do HPA, o VPA <strong>não muda o número de replicas</strong>.<br>
        Ele ajusta os <strong>requests e limits</strong> de cada pod -- muda o <em>tamanho</em>, não a <em>quantidade</em>.
      </div>
    </div>
    <aside class="notes">
      Agora o VPA -- Vertical Pod Autoscaler. Conceito completamente diferente do HPA.
      O HPA adiciona pods. O VPA muda o tamanho dos pods existentes -- ajusta os requests e limits.
      Aqui temos um Deployment com 100m de CPU e 512Mi de memória. 3 replicas fixas.
      Mas será que esses valores estão corretos? Como saber?
    </aside>
  </section>

  <!-- VPA-2: Monitoring detecta uso real -->
  <section class="center">
    <h3 style="margin-bottom:10px;">VPA -- Monitorando o uso real</h3>
    <div style="display:flex; flex-direction:column; align-items:center; gap:15px; margin-top:15px;">

      <!-- Deployment + Pods -->
      <div style="display:flex; align-items:center; justify-content:center; gap:20px;">
        <div style="text-align:center;">
          <div style="border:2px solid #999; border-radius:8px; padding:10px 14px; background:rgba(255,255,255,0.05);">
            <div style="font-size:0.6em; color:#aaa; font-family:monospace; text-align:left;">cpu: <strong style="color:#42a5f5;">100m</strong><br>memory: <strong style="color:#ab47bc;">512Mi</strong></div>
          </div>
          <div style="font-size:0.65em; color:#999; margin-top:4px;">Deployment</div>
        </div>

        <div style="font-size:1.2em; color:#999;">&#10132;</div>

        <div style="display:flex; gap:10px;">
          <div style="text-align:center;">
            <div style="border:3px solid #ff9800; border-radius:10px; padding:8px 12px; background:rgba(255,152,0,0.08);">
              <div style="border:2px dashed #ff9800; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
          <div style="text-align:center;">
            <div style="border:3px solid #ff9800; border-radius:10px; padding:8px 12px; background:rgba(255,152,0,0.08);">
              <div style="border:2px dashed #ff9800; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
          <div style="text-align:center;">
            <div style="border:3px solid #ff9800; border-radius:10px; padding:8px 12px; background:rgba(255,152,0,0.08);">
              <div style="border:2px dashed #ff9800; border-radius:6px; padding:6px 8px;">
                <div style="font-size:0.8em;">&#9881;</div>
              </div>
              <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Monitoring mostra uso real -->
      <div class="fragment fade-up" data-fragment-index="1" style="text-align:center;">
        <div style="border:2px solid #ff9800; border-radius:8px; padding:12px 20px; background:rgba(255,152,0,0.08);">
          <div style="font-size:0.65em; color:#ff9800; font-weight:bold;">Prometheus / Metrics</div>
          <div style="font-size:0.6em; color:#aaa; font-family:monospace; margin-top:6px;">
            Uso real: cpu <strong style="color:#42a5f5;">~30m</strong> (30%) | memory <strong style="color:#ab47bc;">~200Mi</strong> (40%)
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="2" style="max-width:600px; margin:15px auto 0;">
      <div class="key-message" style="text-align:left;">
        Configuramos 100m de CPU e 512Mi de memória. Mas a aplicação usa apenas <strong>30m e 200Mi</strong>.<br>
        <span style="color:#f44336;">70% da CPU e 60% da memória estão sendo desperdiçados</span> em cada pod.
      </div>
    </div>
    <aside class="notes">
      O VPA usa o Prometheus para monitorar o uso real da aplicação por até 30 dias.
      Nesse caso, configuramos 100m de CPU e 512Mi de memória, mas a aplicação está usando apenas 30m e 200Mi.
      Estamos desperdiçando 70% da CPU e 60% da memória reservadas. Multiplicado por 3 replicas, é um desperdício enorme.
    </aside>
  </section>

  <!-- VPA-3: Recomendação -->
  <section class="center">
    <h3 style="margin-bottom:10px;">VPA -- Recomendação de right-sizing</h3>
    <div style="display:flex; align-items:center; justify-content:center; gap:30px; margin-top:20px;">

      <!-- Antes (pod grande) -->
      <div style="text-align:center;">
        <div style="font-size:0.6em; color:#f44336; margin-bottom:6px;">Antes</div>
        <div style="border:3px solid #f44336; border-radius:12px; padding:18px 22px; background:rgba(244,67,54,0.08); transition:all 0.5s;">
          <div style="border:2px dashed #f44336; border-radius:8px; padding:14px 18px;">
            <div style="font-size:1.4em;">&#9881;</div>
            <div style="font-size:0.55em; color:#f44336; margin-top:4px;">CONTAINER</div>
          </div>
          <div style="font-size:0.7em; color:#fff; margin-top:6px;">POD</div>
          <div style="font-size:0.55em; color:#f44336; font-family:monospace; margin-top:4px;">cpu: 100m<br>mem: 512Mi</div>
        </div>
      </div>

      <!-- Seta com VPA -->
      <div class="fragment fade-in" data-fragment-index="1" style="text-align:center;">
        <div style="border:2px solid #ab47bc; border-radius:8px; padding:10px 16px; background:rgba(171,71,188,0.08);">
          <div style="font-size:0.65em; color:#ab47bc; font-weight:bold;">VPA</div>
          <div style="font-size:0.5em; color:#aaa; margin-top:4px;">Recomenda:</div>
          <div style="font-size:0.55em; color:#4caf50; font-family:monospace; font-weight:bold;">cpu: 35m<br>mem: 220Mi</div>
        </div>
        <div style="font-size:1.2em; color:#ab47bc; margin-top:8px;">&#10132;</div>
      </div>

      <!-- Depois (pod menor) -->
      <div class="fragment fade-in" data-fragment-index="2" style="text-align:center;">
        <div style="font-size:0.6em; color:#4caf50; margin-bottom:6px;">Depois</div>
        <div style="border:3px solid #4caf50; border-radius:10px; padding:10px 14px; background:rgba(76,175,80,0.08); transition:all 0.5s;">
          <div style="border:2px dashed #4caf50; border-radius:6px; padding:8px 10px;">
            <div style="font-size:0.9em;">&#9881;</div>
            <div style="font-size:0.5em; color:#4caf50; margin-top:2px;">CONTAINER</div>
          </div>
          <div style="font-size:0.6em; color:#fff; margin-top:4px;">POD</div>
          <div style="font-size:0.55em; color:#4caf50; font-family:monospace; margin-top:4px;">cpu: 35m<br>mem: 220Mi</div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="3" style="max-width:650px; margin:15px auto 0;">
      <div class="key-message" style="text-align:left;">
        O VPA analisa o uso histórico e recomenda valores <strong>right-sized</strong>.<br>
        No modo <strong>Auto</strong>: aplica automaticamente e <span style="color:#ff9800;">reinicia os pods</span>.<br>
        No modo <strong>Off</strong> (recomendado): apenas sugere. Você lê, valida e aplica manualmente.
      </div>
    </div>
    <aside class="notes">
      O VPA analisou 30 dias de dados do Prometheus e recomenda: cpu 35m e memória 220Mi.
      Isso é o right-sizing: ajustar os recursos ao uso real da aplicação.
      O VPA tem dois modos principais: Auto, que aplica automaticamente -- mas reinicia os pods.
      E Off, que é o recomendado para produção: ele apenas gera recomendações, e você decide quando aplicar.
      A abordagem ideal: roda o VPA em homologação no modo Off, coleta as recomendações, adiciona 20% de margem,
      e aplica em produção com confiança.
    </aside>
  </section>

  <!-- VPA-4: Resultado final -->
  <section class="center">
    <h3 style="margin-bottom:10px;">VPA -- O resultado</h3>
    <div style="display:flex; align-items:center; justify-content:center; gap:20px; margin-top:15px;">

      <div style="text-align:center;">
        <div style="border:2px solid #4caf50; border-radius:8px; padding:10px 14px; background:rgba(76,175,80,0.05);">
          <div style="font-size:0.6em; color:#aaa; font-family:monospace; text-align:left;">cpu: <strong style="color:#4caf50;">35m</strong> <span style="color:#666; font-size:0.8em;">(era 100m)</span><br>memory: <strong style="color:#4caf50;">220Mi</strong> <span style="color:#666; font-size:0.8em;">(era 512Mi)</span></div>
        </div>
        <div style="font-size:0.65em; color:#999; margin-top:4px;">Deployment</div>
      </div>

      <div style="font-size:1.2em; color:#999;">&#10132;</div>

      <div style="display:flex; gap:10px;">
        <div style="text-align:center;">
          <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
            <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
              <div style="font-size:0.8em;">&#9881;</div>
              <div style="font-size:0.45em; color:#4caf50;">RIGHT-SIZED</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>
        <div style="text-align:center;">
          <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
            <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
              <div style="font-size:0.8em;">&#9881;</div>
              <div style="font-size:0.45em; color:#4caf50;">RIGHT-SIZED</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>
        <div style="text-align:center;">
          <div style="border:3px solid #4caf50; border-radius:10px; padding:8px 12px; background:rgba(76,175,80,0.08);">
            <div style="border:2px dashed #4caf50; border-radius:6px; padding:6px 8px;">
              <div style="font-size:0.8em;">&#9881;</div>
              <div style="font-size:0.45em; color:#4caf50;">RIGHT-SIZED</div>
            </div>
            <div style="font-size:0.6em; color:#fff; margin-top:3px;">POD</div>
          </div>
        </div>
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="1" style="max-width:650px; margin:20px auto 0;">
      <div class="key-message" style="text-align:left;">
        <strong>CPU</strong>: 100m &#10132; 35m = <span style="color:#4caf50;">65% de economia</span> no scheduler<br>
        <strong>Memória</strong>: 512Mi &#10132; 220Mi = <span style="color:#4caf50;">57% de economia</span> por pod<br>
        Multiplicado por 3 replicas = capacidade liberada para <strong>outros workloads</strong>.
      </div>
    </div>

    <div class="fragment fade-up" data-fragment-index="2" style="max-width:650px; margin:10px auto 0;">
      <div style="border-left:3px solid #ff9800; padding:8px 15px; background:rgba(255,152,0,0.05); font-size:0.7em;">
        <strong style="color:#ff9800;">HPA + VPA juntos?</strong> Não é recomendado no mesmo recurso (CPU).
        O VPA ajusta requests, o que muda a base de cálculo do HPA. Use VPA para right-sizing inicial
        e HPA para elasticidade em produção.
      </div>
    </div>
    <aside class="notes">
      O resultado: economia de 65% em CPU e 57% em memória, em cada pod. Multiplicado por 3 replicas, a diferença é enorme.
      Recursos liberados que podem ser usados por outros workloads no mesmo nó.
      Ponto importante: não é recomendado usar HPA e VPA juntos no mesmo recurso.
      O VPA muda os requests, e o HPA usa os requests como base de cálculo.
      A abordagem recomendada: use o VPA para encontrar os valores corretos de right-sizing,
      aplique no Deployment, e depois configure o HPA para elasticidade horizontal.
      Vamos demonstrar o VPA na prática com o nosso workload-simulator na Parte 3.
      Agora que cobrimos os fundamentos -- requests, limits, overcommit, scheduler, QoS, HPA e VPA --
      vamos para a parte prática: autoscaling ao vivo.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 3 - AUTOSCALING AO VIVO -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Autoscaling ao Vivo</h2>
    <div class="demo-indicator">DEMO INTERATIVA</div>
    <div class="demo-links" style="margin-top:20px;">
      <a class="demo-btn green" href="https://stress-app-app-bom.__CLUSTER_DOMAIN__" target="_blank">Abrir Stress App (app-bom)</a>
      <a class="demo-btn red"   href="https://stress-app-app-ruim.__CLUSTER_DOMAIN__" target="_blank">Abrir Stress App (app-ruim)</a>
      <a class="demo-btn blue"  href="https://resource-dashboard-demo-dashboard.__CLUSTER_DOMAIN__" target="_blank">Abrir Dashboard</a>
    </div>
    <aside class="notes">
      Acabamos de ver toda a teoria: requests, limits, overcommit, scheduler, QoS, HPA e VPA.
      Agora é hora de provar que tudo isso funciona na prática.
      Temos três demonstrações: HPA com carga, OOMKill com memória e VPA com simulador.
    </aside>
  </section>

  <!-- HPA AO VIVO -->
  <section>
    <h2>A fórmula do HPA na prática</h2>
    <pre style="font-size:0.9em;text-align:center;background:#222;padding:20px;border-radius:8px;"><code>réplicas = ceil( atuais x (métrica_atual / métrica_target) )</code></pre>
    <table style="margin-top:20px;">
      <thead><tr><th>Cenário</th><th>Request</th><th>Uso real</th><th>%</th><th>HPA dispara?</th></tr></thead>
      <tbody>
        <tr style="color:#4caf50"><td>app-bom</td><td>50m</td><td>80m</td><td>160%</td><td>Sim (3 réplicas)</td></tr>
        <tr style="color:#f44336"><td>app-ruim</td><td>2000m</td><td>80m</td><td>4%</td><td>Não</td></tr>
      </tbody>
    </table>
    <div class="key-message fragment">
      O request é o denominador da fórmula. Se é gigante, a porcentagem nunca sobe. Vamos comprovar agora.
    </div>
    <aside class="notes">
      Antes de gerar carga, vamos relembrar a fórmula. O HPA calcula: uso atual dividido pelo request.
      Com request de 50m, 80m de uso dá 160% -- escala para 3 réplicas. Com 2000m, dá 4% -- nada acontece.
      Vamos verificar isso ao vivo.
    </aside>
  </section>

  <section>
    <h2>Gerando carga no app-ruim</h2>
    <div class="demo-indicator">DEMO -- Stress App app-ruim</div>
    <div class="demo-links">
      <a class="demo-btn red" href="https://stress-app-app-ruim.__CLUSTER_DOMAIN__" target="_blank">Abrir Stress App (app-ruim)</a>
    </div>
    <ol style="margin-top:20px;">
      <li>Mesma carga, mesma aplicação</li>
      <li>CPU sobe em milicores...</li>
      <li>Mas a <strong>porcentagem</strong> fica ridiculamente baixa</li>
      <li>HPA vê 5%, 10%... longe dos 70%</li>
      <li><strong>Zero réplicas novas</strong></li>
    </ol>
    <div class="key-message fragment">
      Mesma aplicação. Mesma carga. Mesmo HPA. A única diferença são os requests.
      Esse é exatamente o cenário que acontece em clusters reais.
    </div>
    <aside class="notes">
      Vamos gerar carga no app-ruim primeiro. O request é 2000m.
      A porcentagem de CPU nunca chega perto de 70% (que seria 1400m!).
      O HPA está efetivamente morto. Guardem esse resultado -- agora vamos comparar com o app-bom.
    </aside>
  </section>

  <section>
    <h2>Gerando carga no app-bom</h2>
    <div class="demo-indicator">DEMO -- Stress App app-bom</div>
    <div class="demo-links">
      <a class="demo-btn green" href="https://stress-app-app-bom.__CLUSTER_DOMAIN__" target="_blank">Abrir Stress App (app-bom)</a>
    </div>
    <ol style="margin-top:20px;">
      <li>Abrir Stress App do app-bom</li>
      <li>Clicar em <strong>"120s - Moderado"</strong></li>
      <li>Voltar ao Dashboard -- observar CPU subindo</li>
      <li>HPA detecta carga &gt; 70% e escala</li>
      <li>Novas réplicas aparecem</li>
    </ol>
    <div class="key-message fragment">
      Isso é autoscaling funcionando de verdade. Requests corretos = HPA funcional.
    </div>
    <aside class="notes">
      Agora a mesma carga no app-bom. A CPU sobe, ultrapassa 70% do request (35m), e o HPA escala.
      A diferença é gritante: mesma aplicação, mesma carga, mesmo HPA -- só mudaram os requests.
      Se perguntarem por que só um pod mostra CPU alta: o teste gera carga internamente no pod.
      Não é tráfego distribuído. Em produção, o Route distribui entre réplicas.
    </aside>
  </section>

  <!-- OOMKILL -->
  <section>
    <h2>OOMKill -- Limits de Memória</h2>
    <div class="demo-indicator">DEMO -- Stress App</div>
    <div class="demo-links">
      <a class="demo-btn red"   href="https://stress-app-app-ruim.__CLUSTER_DOMAIN__" target="_blank">app-ruim</a>
      <a class="demo-btn green" href="https://stress-app-app-bom.__CLUSTER_DOMAIN__" target="_blank">app-bom</a>
    </div>
    <ul style="margin-top:20px;">
      <li>Memória é <strong>incompressível</strong> -- não tem throttle, tem OOMKill</li>
      <li>Alocar memória progressivamente com <strong>+64 MB</strong></li>
      <li>Observar a barra: verde &rarr; amarela &rarr; vermelha pulsando</li>
      <li>No limit: <strong>OOMKilled</strong> -- pod reiniciado</li>
    </ul>
    <aside class="notes">
      No app-ruim, limit de 2Gi. Clicar em +64MB repetidamente até estourar.
      No app-bom, limit de 256Mi. Mostrar que com menos alocação já fica na zona vermelha.
      O ponto: limits protegem o node. Requests dimensionados corretamente + limits com margem = configuração ideal.
      Lembrem: CPU é compressível (throttle), memória é incompressível (OOMKill). Por isso HPA para memória não funciona.
    </aside>
  </section>

  <!-- VPA AO VIVO -->
  <section>
    <h2>VPA na prática -- Simulador de Carga</h2>
    <div class="demo-indicator">DEMO -- Abrir Simulador de Carga</div>
    <div class="demo-links">
      <a class="demo-btn blue" href="https://workload-simulator-vpa-demo.__CLUSTER_DOMAIN__" target="_blank">Abrir Simulador de Carga</a>
    </div>
    <ul style="margin-top:20px;">
      <li>Aplicação rodando há dias com carga oscilante</li>
      <li>60 min pico (~65 usuários) + 60 min fora de pico (~10 usuários)</li>
      <li>VPA em modo <strong>Off</strong> -- apenas observando</li>
      <li>Configurada com 1000m CPU / 1Gi memória (propositalmente inflado)</li>
    </ul>
    <aside class="notes">
      Vimos o HPA ao vivo. Agora vamos ver o VPA.
      Abrir o Simulador de Carga. Mostrar o gráfico oscilando.
      A aplicação simula um cenário real: horário comercial com pico e fora de pico.
      O VPA está observando e gerando recomendações.
    </aside>
  </section>

  <section>
    <h2>Recomendações do VPA</h2>
    <div class="demo-indicator">DEMO -- Terminal: oc describe vpa</div>
    <div class="demo-links">
      <a class="demo-btn orange" href="https://console-openshift-console.__CLUSTER_DOMAIN__/terminal" target="_blank">Web Terminal</a>
    </div>
    <table style="margin-top:20px;">
      <thead><tr><th>Campo</th><th>Significado</th><th>Uso prático</th></tr></thead>
      <tbody>
        <tr><td><strong>Target</strong></td><td>Valor ideal (p90)</td><td>Use como <strong>requests</strong></td></tr>
        <tr><td><strong>Lower Bound</strong></td><td>Mínimo seguro</td><td>Nunca vá abaixo disso</td></tr>
        <tr><td><strong>Upper Bound</strong></td><td>Picos observados</td><td>Referência para <strong>limits</strong></td></tr>
        <tr><td><strong>Uncapped Target</strong></td><td>Target sem restrições</td><td>Diagnóstico do resourcePolicy</td></tr>
      </tbody>
    </table>
    <aside class="notes">
      Usar o botão Copiar no Simulador de Carga ou executar diretamente:
      oc describe vpa vpa-workload-simulator -n vpa-demo | grep -A 20 "Container Recommendations"
      Comparar os valores recomendados com os 1000m/1Gi configurados.
      O Target mostra onde deveriam estar os requests. A diferença entre o configurado e o recomendado é o desperdício.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 4 - OBSERVABILIDADE -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Observabilidade</h2>
    <div class="demo-indicator">DEMO -- CLI + Console OpenShift</div>
    <div class="demo-links" style="margin-top:15px;">
      <a class="demo-btn orange" href="https://console-openshift-console.__CLUSTER_DOMAIN__/terminal" target="_blank">Web Terminal</a>
      <a class="demo-btn blue"   href="https://console-openshift-console.__CLUSTER_DOMAIN__/monitoring/dashboards" target="_blank">Observe &gt; Dashboards</a>
    </div>
    <aside class="notes">
      Mostramos o problema, explicamos a teoria, comprovamos na prática.
      Agora a pergunta é: como vocês vão identificar esse desperdício no dia a dia?
      A resposta está nas ferramentas de observabilidade nativas do OpenShift.
    </aside>
  </section>

  <section>
    <h2>CLI -- Comandos essenciais</h2>
    <pre><code class="bash"># Uso real de CPU/memória
oc adm top pods -n app-bom
oc adm top pods -n app-ruim

# Status do HPA
oc get hpa -n app-bom
oc get hpa -n app-ruim

# Alocação do node (requests acumulados)
oc describe node | grep -A 5 "Allocated resources"</code></pre>
    <aside class="notes">
      Mostrar esses comandos no terminal/Web Terminal.
      O ponto crítico é o Allocated resources -- mostra a soma dos requests de todos os pods no node.
      Quanto mais inflado, mais rápido o node "lota" na visão do scheduler.
    </aside>
  </section>

  <section>
    <h2>Console -- Dashboards nativos</h2>
    <div class="demo-indicator">DEMO -- OpenShift Console &gt; Observe &gt; Dashboards</div>
    <div class="demo-links">
      <a class="demo-btn blue" href="https://console-openshift-console.__CLUSTER_DOMAIN__/monitoring/dashboards" target="_blank">Abrir Dashboards</a>
    </div>
    <ul style="margin-top:20px;">
      <li><strong>Kubernetes / Compute Resources / Namespace (Pods)</strong></li>
      <li>CPU Usage -- consumo real ao longo do tempo</li>
      <li>CPU Quota -- uso vs requests vs limits (folga de burst)</li>
      <li>Memory Usage -- consumo de memória</li>
      <li>Selecionar app-bom, depois app-ruim -- comparar visualmente</li>
    </ul>
    <div class="key-message fragment">
      Esses dashboards já existem no cluster. Não precisa instalar nada.
      Use-os periodicamente para identificar desperdício.
    </div>
    <aside class="notes">
      Navegar para Observe > Dashboards > Kubernetes / Compute Resources / Namespace (Pods).
      Selecionar app-bom primeiro, depois app-ruim. Mostrar a diferença visual.
      Também mostrar o dashboard de Cluster para a visão geral.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 5 - BOAS PRÁTICAS -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Boas Práticas</h2>
    <aside class="notes">
      Vimos o problema, entendemos a teoria, comprovamos na prática, e sabemos como monitorar.
      Agora vamos consolidar tudo em regras claras que vocês podem aplicar amanhã.
    </aside>
  </section>

  <section>
    <h2>Regras de ouro</h2>
    <ol>
      <li><strong>Requests = uso médio observado</strong> (p50-p75)</li>
      <li><strong>Limits de CPU = 2x a 4x</strong> o request (margem de burst)</li>
      <li><strong>Limits de memória = 1.5x a 2x</strong> o request (OOMKill é destrutivo)</li>
      <li><strong>Nunca requests = limits</strong> exceto para workloads críticos stateful</li>
      <li><strong>Use VPA modo Off</strong> para calibrar com dados reais</li>
      <li><strong>Defina LimitRanges</strong> para impedir configurações extremas</li>
      <li><strong>Monitore continuamente</strong> com dashboards nativos</li>
    </ol>
    <aside class="notes">
      Essas são as regras que consolidam tudo o que vimos hoje.
      A primeira é a mais importante: requests devem refletir o uso real observado, não um chute.
      O VPA em modo Off é a ferramenta que dá esses números com base em dados concretos.
      LimitRanges evitam que alguém configure 8 vCPUs de request num microsserviço que usa 50m.
      E monitoramento contínuo garante que a configuração se mantenha adequada ao longo do tempo.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 6 - ROUTE VS SERVICE -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Route vs Service</h2>
    <h3>Comunicação interna</h3>
    <div class="demo-indicator">DEMO INTERATIVA</div>
    <div class="demo-links" style="margin-top:15px;">
      <a class="demo-btn red"   href="https://stress-app-app-ruim.__CLUSTER_DOMAIN__" target="_blank">app-ruim (Via Route)</a>
      <a class="demo-btn green" href="https://stress-app-app-bom.__CLUSTER_DOMAIN__" target="_blank">app-bom (Via Service)</a>
    </div>
    <aside class="notes">
      Até aqui falamos de CPU e memória. Mas tem outro anti-pattern comum que impacta performance:
      aplicações usando Routes para se comunicar entre si dentro do cluster.
      Vamos demonstrar a diferença de latência.
    </aside>
  </section>

  <section>
    <h2>O anti-pattern</h2>
    <div class="two-col">
      <div>
        <h3 style="color:#f44336">Via Route (errado)</h3>
        <p style="font-size:0.75em;">Pod A &rarr; Router HAProxy &rarr; DNS externo &rarr; TLS &rarr; Router &rarr; Pod B</p>
        <p><strong>6 hops | ~20ms</strong></p>
      </div>
      <div>
        <h3 style="color:#4caf50">Via Service (correto)</h3>
        <p style="font-size:0.75em;">Pod A &rarr; OVN/cluster SDN &rarr; Pod B</p>
        <p><strong>2 hops | ~5ms</strong></p>
      </div>
    </div>
    <table style="margin-top:20px;font-size:0.75em;">
      <thead><tr><th>Cenário</th><th>Use</th></tr></thead>
      <tbody>
        <tr><td>Acesso externo (browsers, APIs públicas)</td><td><strong>Route</strong></td></tr>
        <tr><td>Entre pods no mesmo namespace</td><td><strong>Service</strong> (nome:porta)</td></tr>
        <tr><td>Entre pods em namespaces diferentes</td><td><strong>Service</strong> (nome.ns.svc.cluster.local:porta)</td></tr>
      </tbody>
    </table>
    <div class="key-message fragment">
      Route é a porta de entrada. Não o corredor interno.
    </div>
    <aside class="notes">
      Outro anti-pattern comum: apps se comunicando entre namespaces usando a URL da Route.
      Demonstrar nos stress-apps: Via Route no app-ruim (~20ms) vs Via Service no app-bom (~5ms).
      2x a 3x mais lento. Em produção com centenas de microsserviços, cada chamada via Route adiciona carga no Router.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 7 - GITOPS E POLICIES -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Protegendo o Cluster</h2>
    <h3>GitOps + Policies</h3>
    <div class="demo-links" style="margin-top:15px;">
      <a class="demo-btn dark"   href="https://openshift-gitops-server-openshift-gitops.__CLUSTER_DOMAIN__" target="_blank">Argo CD</a>
      <a class="demo-btn dark"   href="https://console-openshift-console.__CLUSTER_DOMAIN__/multicloud/infrastructure/clusters/managed" target="_blank">ACM Console</a>
      <a class="demo-btn orange" href="https://console-openshift-console.__CLUSTER_DOMAIN__/terminal" target="_blank">Web Terminal</a>
    </div>
    <aside class="notes">
      Sabemos como configurar corretamente. Mas como garantir que ninguém desfaça o trabalho?
      A resposta está em três camadas de proteção: CI com Tekton, CD com ArgoCD, e governança com ACM Policies.
    </aside>
  </section>

  <section>
    <h2>Três camadas de proteção</h2>
    <table>
      <thead><tr><th>Camada</th><th>Ferramenta</th><th>Responsabilidade</th></tr></thead>
      <tbody>
        <tr><td><span class="badge-blue">CI</span></td><td>Tekton Pipelines</td><td>Padroniza o build</td></tr>
        <tr><td><span class="badge-green">CD</span></td><td>Argo CD (GitOps)</td><td>Git é a fonte de verdade</td></tr>
        <tr><td><span class="badge-yellow">Governança</span></td><td>ACM Policies</td><td>Audita e reporta violações</td></tr>
      </tbody>
    </table>
    <div class="key-message fragment">
      Pipeline padroniza o build. GitOps protege o deploy. Policies garantem conformidade.
      Três camadas, zero "oc edit".
    </div>
    <aside class="notes">
      Cada camada tem uma responsabilidade. Juntas, formam uma defesa em profundidade.
      Dev entrega código, pipeline cria imagem, ArgoCD deploya do Git, ACM audita.
    </aside>
  </section>

  <section>
    <h2>ACM Governance -- Policies</h2>
    <div class="demo-indicator">DEMO -- ACM Console &gt; Governance</div>
    <div class="demo-links">
      <a class="demo-btn dark" href="https://console-openshift-console.__CLUSTER_DOMAIN__/multicloud/governance/policies" target="_blank">Abrir ACM Governance</a>
    </div>
    <table style="margin-top:20px;font-size:0.8em;">
      <thead><tr><th>Policy</th><th>Status</th><th>Quem viola</th></tr></thead>
      <tbody>
        <tr><td>policy-resource-ceiling</td><td><span class="badge-red">NonCompliant</span></td><td>app-ruim (2 CPU &gt; teto 1 CPU)</td></tr>
        <tr><td>policy-required-labels</td><td><span class="badge-red">NonCompliant</span></td><td>app-ruim (faltam labels)</td></tr>
        <tr><td>policy-no-guaranteed-stateless</td><td><span class="badge-red">NonCompliant</span></td><td>app-ruim (req = lim)</td></tr>
      </tbody>
    </table>
    <aside class="notes">
      Abrir ACM Console > Governance > Policies. Mostrar as 3 policies.
      Clicar em cada uma e mostrar qual cluster, namespace e recurso está violando.
      A policy não pune -- ela ilumina. Sem policies, ninguém sabe que tem problema.
    </aside>
  </section>

  <section>
    <h2>Correção via GitOps</h2>
    <div class="demo-indicator">DEMO -- Git commit + Argo CD sync</div>
    <div class="demo-links">
      <a class="demo-btn dark" href="https://openshift-gitops-server-openshift-gitops.__CLUSTER_DOMAIN__" target="_blank">Abrir Argo CD</a>
    </div>
    <ol style="margin-top:20px;">
      <li>Corrigir labels no Git (<code>gitops/app-bom/deployment.yaml</code>)</li>
      <li>Commit e push</li>
      <li>Argo CD sincroniza automaticamente</li>
      <li>ACM: app-bom fica <span class="badge-green">Compliant</span></li>
    </ol>
    <div class="key-message fragment">
      A correção veio pelo Git. Ninguém fez "oc edit".
      O Git é a fonte de verdade e a policy validou automaticamente.
    </div>
    <aside class="notes">
      Demonstrar: editar o deployment no Git, adicionar labels, commit e push.
      Mostrar no ArgoCD o sync. Voltar ao ACM e mostrar que app-bom ficou Compliant.
    </aside>
  </section>

  <section>
    <h2>Argo CD selfHeal</h2>
    <div class="demo-indicator">DEMO -- Delete + auto-recovery</div>
    <div class="demo-links">
      <a class="demo-btn dark"   href="https://openshift-gitops-server-openshift-gitops.__CLUSTER_DOMAIN__" target="_blank">Argo CD</a>
      <a class="demo-btn orange" href="https://console-openshift-console.__CLUSTER_DOMAIN__/terminal" target="_blank">Web Terminal</a>
    </div>
    <ol style="margin-top:20px;">
      <li>Mostrar que app-bom está Synced e Healthy no ArgoCD</li>
      <li>Simular acidente: <code>oc delete route stress-app -n app-bom</code></li>
      <li>ArgoCD detecta drift e <strong>recria automaticamente</strong></li>
      <li>Status volta para Synced + Healthy</li>
    </ol>
    <div class="key-message fragment">
      Mesmo que alguém com cluster-admin apague recursos, o ArgoCD restaura baseado no Git.
      Se um script destrutivo fosse executado num cluster com GitOps, os recursos voltariam automaticamente.
    </div>
    <aside class="notes">
      Essa demo conecta com o incidente real do cliente -- script com oc delete que quebrou o cluster.
      Deletar um recurso, aguardar 10-30 segundos, mostrar o ArgoCD restaurando.
      Narrativa: com GitOps, isso não teria causado downtime permanente.
    </aside>
  </section>
</section>

<!-- ============================================================ -->
<!-- PART 8 - FECHAMENTO -->
<!-- ============================================================ -->
<section>
  <section class="center">
    <h2>Fechamento</h2>
    <h3>Próximos passos</h3>
    <aside class="notes">
      Passamos por toda a jornada: entendemos o problema, aprendemos a teoria,
      comprovamos na prática, monitoramos, e protegemos o cluster.
      Vamos recapitular e falar de próximos passos concretos.
    </aside>
  </section>

  <section>
    <h2>O que vimos hoje</h2>
    <ul>
      <li><strong>Por que acontece</strong> -- requests inflados reservam recursos que nunca são usados</li>
      <li><strong>O impacto real</strong> -- HPA travado, nodes "cheios" com uso de 5%, custo desnecessário</li>
      <li><strong>Como corrigir</strong> -- requests reais, limits com margem, QoS Burstable</li>
      <li><strong>Como descobrir os valores certos</strong> -- VPA modo Off por 7 dias</li>
      <li><strong>Como monitorar</strong> -- dashboards nativos do OpenShift</li>
      <li><strong>Como proteger</strong> -- GitOps + Policies = automação, não documentação</li>
    </ul>
    <aside class="notes">
      Recapitulando a jornada completa. Começamos entendendo por que o problema existe,
      vimos o impacto concreto no cluster, aprendemos os fundamentos, comprovamos na prática com demos ao vivo,
      e fechamos com as ferramentas de observabilidade e proteção. Tudo isso usando recursos nativos do OpenShift.
    </aside>
  </section>

  <section>
    <h2>Próximos passos concretos</h2>
    <ol>
      <li><strong>Deployar VPA modo Off</strong> nos projetos críticos</li>
      <li><strong>Coletar métricas por 7 dias</strong> sem alterar nada</li>
      <li><strong>Analisar recomendações</strong> vs valores atuais</li>
      <li><strong>Ajustar gradualmente</strong> -- começando pelo maior desperdício</li>
      <li><strong>Revisar comunicação entre namespaces</strong> -- Routes vs Services</li>
    </ol>
    <div class="key-message fragment">
      Não é um projeto de meses. É uma mudança de configuração, deployment por deployment,
      com dados concretos guiando cada decisão.
    </div>
    <aside class="notes">
      Esses são passos que podem começar amanhã. O VPA em modo Off não altera nada na aplicação --
      apenas observa e gera recomendações. Em 7 dias vocês terão dados concretos para tomar decisões.
      A revisão de Routes versus Services é um quick-win: identificar chamadas internas que passam pela Route
      e trocar por Service reduz latência imediatamente.
    </aside>
  </section>

  <section class="center">
    <img src="images/redhat-logo.svg" alt="Red Hat" style="width:120px; margin-bottom:20px;">
    <h1 style="font-size:2em">Obrigado!</h1>
    <p style="margin-top:30px;color:#999;">Perguntas?</p>
  </section>
</section>

</div><!-- .slides -->
</div><!-- .reveal -->

<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
(function() {
  var params = new URLSearchParams(window.location.search);
  var isPresenter = params.has('presenter');
  var isFollower  = params.has('follow');
  // Speaker Notes plugin creates iframes that load the same URL.
  // One of them shows the NEXT slide, which would send wrong state via socket.
  // Only the top-level window should connect to Socket.io.
  var isEmbedded = (window.self !== window.top) || !!window.opener;

  Reveal.initialize({
    hash: true,
    slideNumber: 'c/t',
    showSlideNumber: 'all',
    transition: 'slide',
    transitionSpeed: 'fast',
    controlsTutorial: false,
    progress: true,
    center: false,
    width: 1280,
    height: 720,
    margin: 0.05,
    plugins: [ RevealNotes, RevealHighlight ]
  }).then(function() {

    // ----- Multiplex via Socket.io -----
    // ?presenter  = controla os slides e envia estado
    // ?follow     = segue o presenter (teclado/touch desabilitados)
    // (sem param) = navegacao normal independente
    if ((isPresenter || isFollower) && !isEmbedded) {
      var role = isPresenter ? 'presenter' : 'client';
      var socket = io({ query: { role: role } });

      if (isPresenter) {
        var lastSentH = -1, lastSentV = -1, lastSentF = -1;
        function sendState() {
          var indices = Reveal.getIndices();
          var h = indices.h, v = indices.v, f = indices.f || 0;
          // Only emit when state actually changes (avoids Speaker Notes spurious events)
          if (h === lastSentH && v === lastSentV && f === lastSentF) return;
          lastSentH = h; lastSentV = v; lastSentF = f;
          socket.emit('slidechanged', { indexh: h, indexv: v, indexf: f });
        }
        Reveal.on('slidechanged', sendState);
        Reveal.on('fragmentshown', sendState);
        Reveal.on('fragmenthidden', sendState);
      } else {
        // Follower: disable local navigation, follow presenter
        Reveal.configure({ keyboard: false, touch: false, controls: false });
        socket.on('slidechanged', function(data) {
          var f = (data.indexf != null && data.indexf >= 0) ? data.indexf : undefined;
          Reveal.slide(data.indexh, data.indexv, f);
        });
        socket.on('fragmentchanged', function(data) {
          var f = (data.indexf != null && data.indexf >= 0) ? data.indexf : undefined;
          Reveal.slide(data.indexh, data.indexv, f);
        });
      }
    }

    // ----- Hide global logo on cover slide (already has large logo) -----
    var globalLogo = document.querySelector('.global-logo');
    function toggleLogo() {
      var idx = Reveal.getIndices();
      globalLogo.style.display = (idx.h === 0 && idx.v === 0) ? 'none' : 'block';
    }
    toggleLogo();
    Reveal.on('slidechanged', toggleLogo);

    // ----- Disable demo buttons if cluster domain not set -----
    var links = document.querySelectorAll('.demo-btn');
    var marker = '__CLUSTER' + '_DOMAIN__';
    links.forEach(function(link) {
      if (link.href && link.href.indexOf(marker) !== -1) {
        link.classList.add('disabled');
        link.removeAttribute('href');
        link.title = 'Dominio do cluster nao detectado';
      }
    });
  });
})();
</script>
</body>
</html>
